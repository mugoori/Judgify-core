# ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆ ê°œë°œ ê³„íšì„œ

**í”„ë¡œì íŠ¸ëª…**: TriFlow AI ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆ (Inventory Management Module)
**ë²„ì „**: 1.0.0
**ì‘ì„±ì¼**: 2025-11-18
**ëŒ€ìƒ ì‹œìŠ¤í…œ**: TriFlow AI Desktop App (Tauri + React + TypeScript + Rust)
**ê°œë°œ ê¸°ê°„**: 12ì£¼ (Phase 11 ~ Phase 15)
**ì‘ì„±ì**: AI Development Team

---

## ğŸ“‹ ëª©ì°¨

1. [í”„ë¡œì íŠ¸ ê°œìš” ë° í†µí•© ë°©ì•ˆ](#1-í”„ë¡œì íŠ¸-ê°œìš”-ë°-í†µí•©-ë°©ì•ˆ)
2. [ê¸°ìˆ  ìŠ¤íƒ ë° ì•„í‚¤í…ì²˜](#2-ê¸°ìˆ -ìŠ¤íƒ-ë°-ì•„í‚¤í…ì²˜)
3. [7ê°œ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„](#3-7ê°œ-ëª¨ë“ˆ-ìƒì„¸-ì„¤ê³„)
4. [ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„](#4-ë°ì´í„°ë² ì´ìŠ¤-ìŠ¤í‚¤ë§ˆ-ì„¤ê³„)
5. [AI ê¸°ëŠ¥ êµ¬í˜„ ì „ëµ](#5-ai-ê¸°ëŠ¥-êµ¬í˜„-ì „ëµ)
6. [ë‹¨ê³„ë³„ ê°œë°œ ì¼ì • (Phase 11-15)](#6-ë‹¨ê³„ë³„-ê°œë°œ-ì¼ì •-phase-11-15)
7. [ìœ„í—˜ ê´€ë¦¬ ë° ëŒ€ì‘ ì „ëµ](#7-ìœ„í—˜-ê´€ë¦¬-ë°-ëŒ€ì‘-ì „ëµ)

---

# 1. í”„ë¡œì íŠ¸ ê°œìš” ë° í†µí•© ë°©ì•ˆ

## 1.1 í”„ë¡œì íŠ¸ ë°°ê²½

### 1.1.1 í˜„ì¬ TriFlow AI ì‹œìŠ¤í…œ í˜„í™©

TriFlow AI Ver2.0 Finalì€ ì œì¡°ì—… ì¤‘ì†Œê¸°ì—…(ì—°ë§¤ì¶œ 50ì–µ~3,000ì–µì›)ì„ ìœ„í•œ **AI ê¸°ë°˜ íŒë‹¨ ì—”ì§„ í”Œë«í¼**ì…ë‹ˆë‹¤. í˜„ì¬ ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¡œ ìš´ì˜ë˜ê³  ìˆìŠµë‹ˆë‹¤:

**Desktop App ì•„í‚¤í…ì²˜**:
- **Frontend**: React 18 + TypeScript 5.0 + Vite 5.0
- **Backend**: Rust (Tauri 1.x) + SQLite
- **AI Integration**: Claude API (Anthropic)
- **Cache System**: Memory-First Hybrid Cache (Redis ëŒ€ì²´)
- **Update System**: NSIS Installer (v0.3.0ë¶€í„° MSI ëŒ€ì²´)

**í˜„ì¬ ì œê³µ ê¸°ëŠ¥**:
1. **Workflow ê´€ë¦¬**: Visual Workflow Builder (n8n ìŠ¤íƒ€ì¼)
2. **íŒë‹¨ ì—”ì§„**: Rule Engine + LLM í•˜ì´ë¸Œë¦¬ë“œ íŒë‹¨
3. **ì™¸ë¶€ ì—°ë™**: MES/ERP ì‹œìŠ¤í…œ í†µí•© (MCP Protocol)
4. **ëŒ€ì‹œë³´ë“œ**: ì‹¤ì‹œê°„ ë°ì´í„° ì‹œê°í™”
5. **ì±„íŒ… ì¸í„°í˜ì´ìŠ¤**: Claude ê¸°ë°˜ AI ì–´ì‹œìŠ¤í„´íŠ¸

### 1.1.2 ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆ ê°œë°œ í•„ìš”ì„±

ì œì¡°ì—… ì¤‘ì†Œê¸°ì—…ì˜ ê°€ì¥ í° ìš´ì˜ ê³¼ì œ ì¤‘ í•˜ë‚˜ëŠ” **ì¬ê³  ê´€ë¦¬**ì…ë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œë“¤ì´ ì¡´ì¬í•©ë‹ˆë‹¤:

**í˜„ì¬ ê³ ê°ì‚¬ Pain Points**:
1. âŒ **ìœ í†µê¸°í•œ ê´€ë¦¬ ë¶€ì¬**: íê¸° ë¹„ìš© ì¦ê°€ (ì—°ê°„ í‰ê·  2ì–µì› ì†ì‹¤)
2. âŒ **ì•ˆì „ì¬ê³  ìˆ˜ë™ ê´€ë¦¬**: ì¬ì£¼ë¬¸ ì‹œì  ë†“ì¹¨ â†’ ìƒì‚° ì§€ì—°
3. âŒ **ë°œì£¼ ë¹„íš¨ìœ¨**: ê³¼ë‹¤ ë°œì£¼ ë˜ëŠ” ë¶€ì¡± ë°œì£¼ ë°˜ë³µ
4. âŒ **FIFO ë¯¸ì¤€ìˆ˜**: ì„ ì…ì„ ì¶œ ê´€ë¦¬ ì‹¤íŒ¨ â†’ ë¶ˆëŸ‰ë¥  ì¦ê°€
5. âŒ **ë¹„ìš© ë¶„ì„ ì–´ë ¤ì›€**: ì›ìì¬ ë¹„ìš© ë³€ë™ ì¶”ì  ë¶ˆê°€
6. âŒ **ìˆ˜ì‘ì—… ë¦¬í¬íŠ¸**: ì¼ì¼ ì¬ê³  í˜„í™© Excel ìˆ˜ì‘ì—… (1ì¼ 2ì‹œê°„ ì†Œìš”)
7. âŒ **MES/ERP ë‹¨ì ˆ**: ì¬ê³  ë°ì´í„°ì™€ ìƒì‚° ê³„íš ë¶ˆì¼ì¹˜

**ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆ ë„ì… íš¨ê³¼** (ì˜ˆìƒ):
- âœ… **íê¸° ë¹„ìš© 80% ì ˆê°**: AI ê¸°ë°˜ ìš°ì„ ì†Œë¹„ ì¶”ì²œ (2ì–µ â†’ 4ì²œë§Œì›)
- âœ… **ë°œì£¼ ì •í™•ë„ 95% ë‹¬ì„±**: ìµœì  ë°œì£¼ëŸ‰ + íƒ€ì´ë° ìë™ ê³„ì‚°
- âœ… **ë¦¬í¬íŠ¸ ì‹œê°„ 95% ë‹¨ì¶•**: 2ì‹œê°„ â†’ 5ë¶„ (ì¼ì¼ 1.9ì‹œê°„ ì ˆê°)
- âœ… **ì¬ê³  íšŒì „ìœ¨ 30% ê°œì„ **: MRP ë¶„ì„ ê¸°ë°˜ ìµœì í™”
- âœ… **MES/ERP ì‹¤ì‹œê°„ ì—°ë™**: ë°ì´í„° ì¼ê´€ì„± í™•ë³´

### 1.1.3 í”„ë¡œì íŠ¸ ëª©í‘œ

**ìµœì¢… ëª©í‘œ**: ì œì¡°ì—… ì¤‘ì†Œê¸°ì—…ì´ **AI ê¸°ë°˜ ì¬ê³  ìµœì í™”**ë¥¼ í†µí•´ **ìš´ì˜ ë¹„ìš©ì„ ì—°ê°„ 30% ì ˆê°**í•˜ê³ , **ì¬ê³  ê´€ë¦¬ ì—…ë¬´ ì‹œê°„ì„ 90% ë‹¨ì¶•**í•  ìˆ˜ ìˆëŠ” í†µí•© ì†”ë£¨ì…˜ ì œê³µ

**êµ¬ì²´ì  ëª©í‘œ**:
1. **7ê°œ í•µì‹¬ ëª¨ë“ˆ** ê°œë°œ ë° í†µí•©
   - ìœ í†µê¸°í•œ ê´€ë¦¬, ì•ˆì „ì¬ê³ , MRP, ìë™ë°œì£¼ì„œ, ë¹„ìš©ê´€ë¦¬, ë¦¬í¬íŠ¸, ëŒ€ì‹œë³´ë“œ
2. **TriFlow AI Desktop App ì™„ì „ í†µí•©**
   - ê¸°ì¡´ Workflow/íŒë‹¨ ì—”ì§„ê³¼ ì—°ê³„
   - ë‹¨ì¼ UI/UXì—ì„œ ëª¨ë“  ê¸°ëŠ¥ ì œê³µ
3. **MES/ERP ì‹¤ì‹œê°„ ì—°ë™**
   - API í†µí•©, CSV/Excel ê°€ì ¸ì˜¤ê¸°, ìˆ˜ë™ ì…ë ¥ ì§€ì›
4. **Claude API ê¸°ë°˜ AI ê¸°ëŠ¥**
   - íê¸° ìµœì†Œí™” ì•Œê³ ë¦¬ì¦˜, ì´ìƒ íŒ¨í„´ ê°ì§€, ë°œì£¼ íƒ€ì´ë° ì¶”ì²œ
5. **ì¦‰ì‹œ ì‚¬ìš© ê°€ëŠ¥í•œ ì™„ì„±ë„**
   - ì„¤ì¹˜ í›„ 30ë¶„ ë‚´ ì²« ë²ˆì§¸ ì¬ê³  ë¶„ì„ ê°€ëŠ¥
   - í•™ìŠµ ê³¡ì„  ìµœì†Œí™” (ê¸°ì¡´ TriFlow AI ì‚¬ìš©ì ì¹œí™”ì )

## 1.2 TriFlow AI Desktop App í†µí•© ì „ëµ

### 1.2.1 í†µí•© ì•„í‚¤í…ì²˜ ê°œìš”

ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆì€ **ê¸°ì¡´ TriFlow AI Desktop Appì˜ ìƒˆë¡œìš´ íƒ­**ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤. ê¸°ì¡´ ì‹œìŠ¤í…œê³¼ ì™„ì „íˆ í†µí•©ë˜ì–´ ë‹¤ìŒê³¼ ê°™ì€ ì´ì ì„ ì œê³µí•©ë‹ˆë‹¤:

**í†µí•© ë°©ì‹**:
```
TriFlow AI Desktop App
â”œâ”€â”€ [ê¸°ì¡´] Home íƒ­
â”œâ”€â”€ [ê¸°ì¡´] Workflows íƒ­
â”œâ”€â”€ [ê¸°ì¡´] Judgment íƒ­
â”œâ”€â”€ [ê¸°ì¡´] Dashboard íƒ­
â”œâ”€â”€ [ê¸°ì¡´] Chat íƒ­
â””â”€â”€ [ì‹ ê·œ] Inventory Management íƒ­ â­
    â”œâ”€â”€ ìœ í†µê¸°í•œ ê´€ë¦¬
    â”œâ”€â”€ ì•ˆì „ì¬ê³ 
    â”œâ”€â”€ MRP
    â”œâ”€â”€ ìë™ë°œì£¼ì„œ
    â”œâ”€â”€ ë¹„ìš©ê´€ë¦¬
    â”œâ”€â”€ ì¼ì¼ ë¦¬í¬íŠ¸
    â””â”€â”€ ëŒ€ì‹œë³´ë“œ
```

**ê¸°ì¡´ ì‹œìŠ¤í…œ ì¬ì‚¬ìš© ìš”ì†Œ**:
| ê¸°ì¡´ ì‹œìŠ¤í…œ | ì¬ê³  ëª¨ë“ˆ í™œìš© ë°©ì•ˆ |
|------------|-------------------|
| **Workflow Engine** | ì¬ê³  ì•Œë¦¼ ì›Œí¬í”Œë¡œìš° ìë™ ìƒì„± |
| **Judgment Engine** | ì¬ì£¼ë¬¸ ì—¬ë¶€ íŒë‹¨, ì´ìƒ íŒ¨í„´ ê°ì§€ |
| **Claude API Integration** | íê¸° ìµœì†Œí™” ì•Œê³ ë¦¬ì¦˜, ë°œì£¼ íƒ€ì´ë° AI ì¶”ì²œ |
| **SQLite Database** | ì¬ê³  ë°ì´í„° ì €ì¥ (ê¸°ì¡´ DB í™•ì¥) |
| **Cache System** | ì¬ê³  í˜„í™© ì‹¤ì‹œê°„ ì¡°íšŒ ì„±ëŠ¥ ìµœì í™” |
| **MCP Protocol** | MES/ERP ì—°ë™ (ê¸°ì¡´ Connector ì¬ì‚¬ìš©) |
| **Notification System** | ì¬ì£¼ë¬¸ ì•Œë¦¼, ìœ í†µê¸°í•œ ê²½ê³  |

### 1.2.2 ë°ì´í„° í†µí•© ì „ëµ

**SQLite ë°ì´í„°ë² ì´ìŠ¤ í™•ì¥**:

ê¸°ì¡´ TriFlow AI Desktop Appì€ `~/.triflow/triflow.db` SQLite íŒŒì¼ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì¬ê³  ëª¨ë“ˆì€ **ë™ì¼í•œ DB íŒŒì¼ì— ìƒˆ í…Œì´ë¸”ì„ ì¶”ê°€**í•˜ì—¬ ë°ì´í„° ì¼ê´€ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.

```sql
-- ê¸°ì¡´ í…Œì´ë¸” (ì˜ˆì‹œ)
workflows
judgment_executions
cache_entries
mcp_connections

-- ì‹ ê·œ ì¶”ê°€ í…Œì´ë¸” (ì¬ê³  ëª¨ë“ˆ)
inventory_items          -- ì¬ê³  í’ˆëª© ë§ˆìŠ¤í„°
inventory_transactions   -- ì…ì¶œê³  ê±°ë˜
safety_stock_settings    -- ì•ˆì „ì¬ê³  ì„¤ì •
expiration_tracking      -- ìœ í†µê¸°í•œ ì¶”ì 
purchase_orders          -- ë°œì£¼ì„œ
material_costs           -- ì›ìì¬ ë¹„ìš©
daily_reports            -- ì¼ì¼ ë¦¬í¬íŠ¸
```

**ë°ì´í„° ë™ê¸°í™” ì „ëµ**:
1. **MES/ERP â†’ TriFlow AI**: API í´ë§ (5ë¶„ ê°„ê²©) ë˜ëŠ” Webhook
2. **TriFlow AI â†’ MES/ERP**: ë°œì£¼ì„œ ìƒì„±ì‹œ ìë™ ì „ì†¡
3. **ìˆ˜ë™ ì…ë ¥**: CSV/Excel ê°€ì ¸ì˜¤ê¸° + UI ì§ì ‘ ì…ë ¥
4. **ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸**: WebSocketìœ¼ë¡œ ëŒ€ì‹œë³´ë“œ ìë™ ê°±ì‹ 

### 1.2.3 UI/UX í†µí•© ì „ëµ

**ë””ìì¸ ì‹œìŠ¤í…œ ì¬ì‚¬ìš©**:

ê¸°ì¡´ TriFlow AI Desktop Appì˜ ë””ìì¸ ì‹œìŠ¤í…œì„ 100% ì¬ì‚¬ìš©í•˜ì—¬ **ì¼ê´€ëœ ì‚¬ìš©ì ê²½í—˜**ì„ ì œê³µí•©ë‹ˆë‹¤.

**ì¬ì‚¬ìš© ì»´í¬ë„ŒíŠ¸**:
- **ë ˆì´ì•„ì›ƒ**: `MainLayout`, `Sidebar`, `TopBar`
- **ì°¨íŠ¸**: `LineChart`, `BarChart`, `GaugeChart`, `MetricCard`
- **í¼**: `Input`, `Select`, `DatePicker`, `Button`
- **í…Œì´ë¸”**: `DataTable`, `Pagination`, `Filter`
- **ì•Œë¦¼**: `Toast`, `Modal`, `Notification`

**ì‹ ê·œ ê°œë°œ ì»´í¬ë„ŒíŠ¸** (ì¬ê³  ëª¨ë“ˆ ì „ìš©):
- `ExpirationTimeline`: ìœ í†µê¸°í•œ íƒ€ì„ë¼ì¸ ì‹œê°í™”
- `SafetyStockGauge`: ì•ˆì „ì¬ê³  ìˆ˜ì¤€ ê²Œì´ì§€
- `MRPAnalysisChart`: ì¬ê³  íšŒì „ìœ¨ + ì£¼ë¬¸ íŒ¨í„´ ì°¨íŠ¸
- `PurchaseOrderForm`: ìë™ ë°œì£¼ì„œ ìƒì„± í¼
- `CostTrendChart`: ì›ìì¬ ë¹„ìš© ì¶”ì´ ì°¨íŠ¸
- `InventoryHeatmap`: ì¬ê³  í˜„í™© íˆíŠ¸ë§µ

**ë„¤ë¹„ê²Œì´ì…˜ êµ¬ì¡°**:
```
Inventory Management íƒ­ í´ë¦­
â””â”€ 7ê°œ ì„œë¸Œë©”ë‰´ (ì¢Œì¸¡ ì‚¬ì´ë“œë°”)
   â”œâ”€ ğŸ“… ìœ í†µê¸°í•œ ê´€ë¦¬
   â”œâ”€ ğŸ“Š ì•ˆì „ì¬ê³ 
   â”œâ”€ ğŸ”„ MRP
   â”œâ”€ ğŸ“ ìë™ë°œì£¼ì„œ
   â”œâ”€ ğŸ’° ë¹„ìš©ê´€ë¦¬
   â”œâ”€ ğŸ“ˆ ì¼ì¼ ë¦¬í¬íŠ¸
   â””â”€ ğŸ›ï¸ ëŒ€ì‹œë³´ë“œ
```

### 1.2.4 AI ê¸°ëŠ¥ í†µí•© ì „ëµ

**Claude API í™œìš© íŒ¨í„´**:

ì¬ê³  ëª¨ë“ˆì€ ê¸°ì¡´ TriFlow AIì˜ **Claude API Integration**ì„ ì¬ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì€ AI ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤:

**1. Few-shot í•™ìŠµ ê¸°ë°˜ íŒë‹¨** (ê¸°ì¡´ Judgment Engine ì¬ì‚¬ìš©):
```typescript
// ì˜ˆì‹œ: ì¬ì£¼ë¬¸ ì—¬ë¶€ íŒë‹¨
const reorderDecision = await judgmentEngine.execute({
  workflowId: 'inventory-reorder-check',
  inputData: {
    currentStock: 150,
    safetyStock: 200,
    leadTime: 7,
    dailyUsage: 25,
    supplierReliability: 0.85
  },
  method: 'hybrid' // Rule + LLM
});

// ê²°ê³¼:
// {
//   result: true, // ì¬ì£¼ë¬¸ í•„ìš”
//   confidence: 0.92,
//   explanation: "í˜„ì¬ ì¬ê³ (150)ê°€ ì•ˆì „ì¬ê³ (200) ë¯¸ë§Œì´ê³ , 7ì¼ ë¦¬ë“œíƒ€ì„ ë™ì•ˆ 175ê°œ ì†Œì§„ ì˜ˆìƒ. ì¦‰ì‹œ ë°œì£¼ ê¶Œì¥.",
//   recommendedQuantity: 500
// }
```

**2. RAG ì—”ì§„ ê¸°ë°˜ ì¶”ì²œ** (ê¸°ì¡´ pgvector ìœ ì‚¬):
```typescript
// SQLite FTS5 (Full-Text Search) + ì„ë² ë”© ìœ ì‚¬ë„ ê²€ìƒ‰
// pgvector ëŒ€ì‹  ê²½ëŸ‰ ë²¡í„° ê²€ìƒ‰ êµ¬í˜„

const similarCases = await vectorSearch({
  table: 'inventory_transactions',
  queryEmbedding: currentScenarioEmbedding,
  limit: 10,
  minSimilarity: 0.8
});

// ìœ ì‚¬ ì‚¬ë¡€ ê¸°ë°˜ íê¸° ìµœì†Œí™” ì „ëµ ì¶”ì²œ
const wasteReduction = await claudeAPI.chat({
  system: 'ì œì¡°ì—… ì¬ê³  ê´€ë¦¬ ì „ë¬¸ê°€',
  messages: [
    { role: 'user', content: `í˜„ì¬ ìƒí™©: ${currentStatus}` },
    { role: 'user', content: `ìœ ì‚¬ ì‚¬ë¡€: ${similarCases}` },
    { role: 'user', content: 'íê¸° ìµœì†Œí™” ì „ëµ 3ê°€ì§€ ì¶”ì²œí•´ì£¼ì„¸ìš”.' }
  ]
});
```

**3. ìë™í•™ìŠµ ì‹œìŠ¤í…œ í†µí•©** (ê¸°ì¡´ Learning Service ì¬ì‚¬ìš©):

ì¬ê³  ëª¨ë“ˆë„ TriFlow AIì˜ **ìë™í•™ìŠµ ì‹œìŠ¤í…œ**ì„ í™œìš©í•˜ì—¬ ì§€ì†ì ìœ¼ë¡œ ì •í™•ë„ë¥¼ ê°œì„ í•©ë‹ˆë‹¤:

```typescript
// ì‚¬ìš©ì í”¼ë“œë°± ìˆ˜ì§‘
await feedbackCollector.collect({
  judgmentId: 'reorder-decision-123',
  feedbackType: 'thumbs_up', // ğŸ‘ ì¬ì£¼ë¬¸ ê²°ì •ì´ ì •í™•í–ˆìŒ
  actualOutcome: {
    orderedQuantity: 500,
    leadTimeActual: 6, // ì˜ˆìƒ 7ì¼ë³´ë‹¤ 1ì¼ ë¹¨ë¦¬ ë„ì°©
    stockoutPrevented: true
  }
});

// Few-shot ìƒ˜í”Œ ìë™ ì¶”ê°€
await learningService.addFewShotSample({
  workflowId: 'inventory-reorder-check',
  inputData: { currentStock: 150, safetyStock: 200, ... },
  correctOutput: { result: true, recommendedQuantity: 500 },
  accuracy: 0.95
});

// 3ê°œ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìë™ Rule ì¶”ì¶œ
await learningService.extractRules({
  workflowId: 'inventory-reorder-check',
  algorithm: 'decision_tree' // ë˜ëŠ” 'frequency', 'llm_pattern'
});
```

**AI ê¸°ëŠ¥ë³„ Claude API ì‚¬ìš©ëŸ‰ ì˜ˆì¸¡**:

| ê¸°ëŠ¥ | í˜¸ì¶œ ë¹ˆë„ | ì›” API ë¹„ìš© (ì˜ˆìƒ) |
|------|----------|-------------------|
| íê¸° ìµœì†Œí™” ì¶”ì²œ | 1íšŒ/ì¼ | $15 |
| ì¬ì£¼ë¬¸ íŒë‹¨ | 10íšŒ/ì¼ | $30 |
| ì´ìƒ íŒ¨í„´ ê°ì§€ | 1íšŒ/ì¼ | $10 |
| ë°œì£¼ íƒ€ì´ë° ì¶”ì²œ | 5íšŒ/ì£¼ | $20 |
| ë¹„ìš© ë¶„ì„ ì¸ì‚¬ì´íŠ¸ | 1íšŒ/ì£¼ | $5 |
| **ì´ê³„** | - | **$80/ì›”** |

**ë¹„ìš© ìµœì í™” ì „ëµ**:
- ìºì‹œ í™œìš©: ë™ì¼ ì…ë ¥ 24ì‹œê°„ ìºì‹± â†’ 30% ë¹„ìš© ì ˆê°
- Batch ì²˜ë¦¬: ì—¬ëŸ¬ í’ˆëª© í•œ ë²ˆì— ë¶„ì„ â†’ 20% ë¹„ìš© ì ˆê°
- Rule Engine ìš°ì„ : ê°„ë‹¨í•œ íŒë‹¨ì€ Ruleë¡œ ì²˜ë¦¬ â†’ 50% ë¹„ìš© ì ˆê°
- **ìµœì¢… ì˜ˆìƒ ë¹„ìš©**: $80 â†’ **$28/ì›”** (65% ì ˆê°)

### 1.2.5 MES/ERP ì—°ë™ í†µí•© ì „ëµ

**ê¸°ì¡´ MCP Protocol ì¬ì‚¬ìš©**:

TriFlow AIëŠ” ì´ë¯¸ **MCP (Model Context Protocol)** ê¸°ë°˜ ì™¸ë¶€ ì‹œìŠ¤í…œ ì—°ë™ì„ ì§€ì›í•©ë‹ˆë‹¤. ì¬ê³  ëª¨ë“ˆì€ ì´ë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ MES/ERP í†µí•©ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

**ì§€ì› ì—°ë™ ë°©ì‹**:

| ë°©ì‹ | ì„¤ëª… | ìš°ì„ ìˆœìœ„ | êµ¬í˜„ ë°©ë²• |
|------|------|---------|----------|
| **REST API** | MES/ERPì˜ REST API ì§ì ‘ í˜¸ì¶œ | â­â­â­ | MCP Connector ì‹ ê·œ ê°œë°œ |
| **SOAP API** | ë ˆê±°ì‹œ ì‹œìŠ¤í…œ SOAP í˜¸ì¶œ | â­â­ | MCP Connector ì‹ ê·œ ê°œë°œ |
| **Database ì§ì ‘ ì—°ê²°** | MES/ERP DB ì§ì ‘ ì¿¼ë¦¬ | â­â­ | PostgreSQL/MSSQL MCP |
| **CSV/Excel ê°€ì ¸ì˜¤ê¸°** | íŒŒì¼ ì—…ë¡œë“œ | â­â­â­ | ê¸°ì¡´ íŒŒì¼ ì²˜ë¦¬ ì¬ì‚¬ìš© |
| **ìˆ˜ë™ ì…ë ¥** | UIì—ì„œ ì§ì ‘ ì…ë ¥ | â­â­â­ | í¼ ì»´í¬ë„ŒíŠ¸ |

**MCP Connector ê°œë°œ ì˜ˆì‹œ** (REST API):

```typescript
// src-tauri/src/mcp/inventory_connector.rs

use serde::{Deserialize, Serialize};
use reqwest::Client;

#[derive(Serialize, Deserialize)]
pub struct InventoryItem {
    pub item_code: String,
    pub item_name: String,
    pub current_stock: i32,
    pub unit_price: f64,
    pub last_updated: String,
}

pub struct InventoryMCPConnector {
    client: Client,
    base_url: String,
    api_key: String,
}

impl InventoryMCPConnector {
    pub fn new(base_url: String, api_key: String) -> Self {
        Self {
            client: Client::new(),
            base_url,
            api_key,
        }
    }

    /// MES/ERPì—ì„œ ì¬ê³  í˜„í™© ê°€ì ¸ì˜¤ê¸°
    pub async fn fetch_inventory(&self) -> Result<Vec<InventoryItem>, Box<dyn std::error::Error>> {
        let url = format!("{}/api/v1/inventory", self.base_url);
        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await?;

        let items: Vec<InventoryItem> = response.json().await?;
        Ok(items)
    }

    /// ë°œì£¼ì„œ ì „ì†¡
    pub async fn send_purchase_order(&self, order: PurchaseOrder) -> Result<String, Box<dyn std::error::Error>> {
        let url = format!("{}/api/v1/purchase-orders", self.base_url);
        let response = self.client
            .post(&url)
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(&order)
            .send()
            .await?;

        let order_id: String = response.json().await?;
        Ok(order_id)
    }
}
```

**ì—°ë™ ì„¤ì • UI**:

`Inventory Management > Settings` íƒ­ì—ì„œ MES/ERP ì—°ë™ ì„¤ì •:

```typescript
// Frontend: src/pages/InventorySettings.tsx

interface MESConnection {
  type: 'rest_api' | 'soap' | 'database' | 'csv' | 'manual';
  baseUrl?: string;
  apiKey?: string;
  dbConnectionString?: string;
  syncInterval: number; // ë¶„ ë‹¨ìœ„
  enabled: boolean;
}

const InventorySettings = () => {
  const [connection, setConnection] = useState<MESConnection>({
    type: 'rest_api',
    baseUrl: '',
    apiKey: '',
    syncInterval: 5,
    enabled: false
  });

  const handleTestConnection = async () => {
    const result = await invoke('test_mes_connection', { connection });
    if (result.success) {
      toast.success('MES ì—°ë™ í…ŒìŠ¤íŠ¸ ì„±ê³µ!');
    } else {
      toast.error(`ì—°ë™ ì‹¤íŒ¨: ${result.error}`);
    }
  };

  const handleSave = async () => {
    await invoke('save_mes_connection', { connection });
    toast.success('ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
  };

  return (
    <div className="settings-container">
      <h2>MES/ERP ì—°ë™ ì„¤ì •</h2>

      <Select label="ì—°ë™ ë°©ì‹" value={connection.type} onChange={...}>
        <option value="rest_api">REST API</option>
        <option value="soap">SOAP API</option>
        <option value="database">Database ì§ì ‘ ì—°ê²°</option>
        <option value="csv">CSV/Excel ê°€ì ¸ì˜¤ê¸°</option>
        <option value="manual">ìˆ˜ë™ ì…ë ¥</option>
      </Select>

      {connection.type === 'rest_api' && (
        <>
          <Input label="Base URL" value={connection.baseUrl} onChange={...} />
          <Input label="API Key" type="password" value={connection.apiKey} onChange={...} />
        </>
      )}

      <Input label="ë™ê¸°í™” ì£¼ê¸° (ë¶„)" type="number" value={connection.syncInterval} onChange={...} />

      <Switch label="ìë™ ë™ê¸°í™” í™œì„±í™”" checked={connection.enabled} onChange={...} />

      <div className="button-group">
        <Button onClick={handleTestConnection}>ì—°ê²° í…ŒìŠ¤íŠ¸</Button>
        <Button variant="primary" onClick={handleSave}>ì €ì¥</Button>
      </div>
    </div>
  );
};
```

**ìë™ ë™ê¸°í™” ìŠ¤ì¼€ì¤„ëŸ¬** (Rust Tauri):

```rust
// src-tauri/src/inventory/sync_scheduler.rs

use tokio::time::{interval, Duration};

pub async fn start_sync_scheduler(
    connector: Arc<InventoryMCPConnector>,
    db: Arc<Database>,
    sync_interval_minutes: u64
) {
    let mut interval = interval(Duration::from_secs(sync_interval_minutes * 60));

    loop {
        interval.tick().await;

        info!("Starting MES inventory sync...");

        match connector.fetch_inventory().await {
            Ok(items) => {
                // SQLiteì— ì €ì¥
                for item in items {
                    db.upsert_inventory_item(item).await?;
                }
                info!("Sync completed: {} items updated", items.len());
            }
            Err(e) => {
                error!("Sync failed: {}", e);
                // ì•Œë¦¼ ì „ì†¡
                send_notification("MES ë™ê¸°í™” ì‹¤íŒ¨", &e.to_string()).await;
            }
        }
    }
}
```

## 1.3 ê°œë°œ ë²”ìœ„ ë° ì œì•½ì‚¬í•­

### 1.3.1 ê°œë°œ ë²”ìœ„ (In-Scope)

**Phase 11-15 (12ì£¼) ë™ì•ˆ ê°œë°œí•  ê¸°ëŠ¥**:

âœ… **7ê°œ í•µì‹¬ ëª¨ë“ˆ** (ì„¹ì…˜ 3ì—ì„œ ìƒì„¸ ì„¤ëª…):
1. ìœ í†µê¸°í•œ ê´€ë¦¬ ëª¨ë“ˆ
2. ì•ˆì „ì¬ê³  ëª¨ë“ˆ
3. MRP (ìì¬ì†Œìš”ê³„íš) ëª¨ë“ˆ
4. ìë™ë°œì£¼ì„œ ëª¨ë“ˆ
5. ë¹„ìš©ê´€ë¦¬ ëª¨ë“ˆ
6. ì¼ì¼ ë¦¬í¬íŠ¸ ëª¨ë“ˆ
7. ëŒ€ì‹œë³´ë“œ ëª¨ë“ˆ

âœ… **ë°ì´í„° í†µí•©**:
- SQLite ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„ ë° êµ¬í˜„
- MES/ERP REST API ì—°ë™ (MCP Connector ì‹ ê·œ ê°œë°œ)
- CSV/Excel ê°€ì ¸ì˜¤ê¸° ê¸°ëŠ¥
- ìˆ˜ë™ ì…ë ¥ UI

âœ… **AI ê¸°ëŠ¥**:
- Claude API ê¸°ë°˜ íê¸° ìµœì†Œí™” ì•Œê³ ë¦¬ì¦˜
- ì¬ì£¼ë¬¸ ì—¬ë¶€ ìë™ íŒë‹¨ (Rule + LLM í•˜ì´ë¸Œë¦¬ë“œ)
- ì´ìƒ íŒ¨í„´ ê°ì§€ (ë²¡í„° ê²€ìƒ‰ + í†µê³„ ë¶„ì„)
- ë°œì£¼ íƒ€ì´ë° ì¶”ì²œ
- ë¹„ìš© ë¶„ì„ ì¸ì‚¬ì´íŠ¸ ìƒì„±

âœ… **UI/UX**:
- Inventory Management íƒ­ ì¶”ê°€
- 7ê°œ ì„œë¸Œë©”ë‰´ í˜ì´ì§€
- ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ (WebSocket ì—°ë™)
- ëª¨ë°”ì¼ ë°˜ì‘í˜• ë””ìì¸ (Desktop ìš°ì„ , ëª¨ë°”ì¼ í˜¸í™˜)

âœ… **í…ŒìŠ¤íŠ¸ ë° ë¬¸ì„œí™”**:
- ìœ ë‹› í…ŒìŠ¤íŠ¸ (90% ì»¤ë²„ë¦¬ì§€)
- E2E í…ŒìŠ¤íŠ¸ (Playwright)
- ì‚¬ìš©ì ê°€ì´ë“œ (í•œê¸€)
- API ë¬¸ì„œ (ê°œë°œììš©)

### 1.3.2 ê°œë°œ ì œì™¸ (Out-of-Scope)

âŒ **Phase 11-15ì—ì„œ ë‹¤ë£¨ì§€ ì•ŠëŠ” ê¸°ëŠ¥**:

1. **ëª¨ë°”ì¼ ì•±**: Desktop Appë§Œ ê°œë°œ (í–¥í›„ Phase 16-17ì—ì„œ ê³ ë ¤)
2. **SOAP API ì—°ë™**: REST APIë§Œ ìš°ì„  ì§€ì› (Phase 18ì—ì„œ ê³ ë ¤)
3. **Database ì§ì ‘ ì—°ê²°**: API í†µí•© ìš°ì„  (Phase 19ì—ì„œ ê³ ë ¤)
4. **ë°”ì½”ë“œ/RFID ìŠ¤ìº”**: ìˆ˜ë™ ì…ë ¥/API í†µí•©ë§Œ ì§€ì›
5. **ë‹¤êµ­ì–´ ì§€ì›**: í•œêµ­ì–´ë§Œ ì§€ì› (ì˜ì–´ëŠ” Phase 20ì—ì„œ ê³ ë ¤)
6. **í´ë¼ìš°ë“œ ë°±ì—…**: ë¡œì»¬ SQLiteë§Œ ì§€ì› (í´ë¼ìš°ë“œëŠ” Phase 21ì—ì„œ ê³ ë ¤)
7. **ê³ ê¸‰ ML ëª¨ë¸**: Claude API + ì „í†µì  ì•Œê³ ë¦¬ì¦˜ë§Œ ì‚¬ìš© (ë”¥ëŸ¬ë‹ ëª¨ë¸ ì œì™¸)

### 1.3.3 ê¸°ìˆ ì  ì œì•½ì‚¬í•­

**Desktop App ì œì•½ì‚¬í•­**:
- **í”Œë«í¼**: Windows 10/11 x64 (macOS/LinuxëŠ” ë¯¸ì§€ì›)
- **ìµœì†Œ ì‚¬ì–‘**: RAM 4GB, ì €ì¥ê³µê°„ 500MB
- **ë„¤íŠ¸ì›Œí¬**: ì¸í„°ë„· ì—°ê²° í•„ìˆ˜ (Claude API, MES/ERP ì—°ë™)
- **ê¶Œí•œ**: ê´€ë¦¬ì ê¶Œí•œ ë¶ˆí•„ìš” (ì¼ë°˜ ì‚¬ìš©ì ê¶Œí•œ)

**ë°ì´í„°ë² ì´ìŠ¤ ì œì•½ì‚¬í•­**:
- **SQLite í¬ê¸° ì œí•œ**: ìµœëŒ€ 100GB (ì¼ë°˜ì ìœ¼ë¡œ 1-5GB)
- **ë™ì‹œ ì ‘ì†**: ë‹¨ì¼ ì‚¬ìš©ì (Desktop App íŠ¹ì„±ìƒ)
- **ë°±ì—…**: ì‚¬ìš©ì ìˆ˜ë™ ë°±ì—… (ìë™ ë°±ì—… ë¯¸ì§€ì›)

**AI ê¸°ëŠ¥ ì œì•½ì‚¬í•­**:
- **Claude API ì˜ì¡´ì„±**: ì¸í„°ë„· ì—†ìœ¼ë©´ AI ê¸°ëŠ¥ ë¶ˆê°€
- **ë¹„ìš©**: ì›” $28 ì˜ˆìƒ (ê³ ê°ì‚¬ ë¶€ë‹´)
- **ì‘ë‹µ ì‹œê°„**: í‰ê·  2-5ì´ˆ (Claude API í˜¸ì¶œ ì‹œ)

**MES/ERP ì—°ë™ ì œì•½ì‚¬í•­**:
- **API ì˜ì¡´ì„±**: MES/ERPê°€ REST API ì œê³µí•´ì•¼ í•¨
- **ë°ì´í„° í˜•ì‹**: JSON ë˜ëŠ” CSV ë§Œ ì§€ì›
- **ì¸ì¦**: Bearer Token ë˜ëŠ” API Key ë°©ì‹ë§Œ ì§€ì›

### 1.3.4 ì„±ê³µ ê¸°ì¤€

**Phase 15 ì™„ë£Œ ì‹œì  (12ì£¼ í›„) ë‹¬ì„± ëª©í‘œ**:

**1. ê¸°ëŠ¥ ì™„ì„±ë„**:
- âœ… 7ê°œ ëª¨ë“ˆ 100% ê°œë°œ ì™„ë£Œ
- âœ… MES/ERP REST API ì—°ë™ í…ŒìŠ¤íŠ¸ ì™„ë£Œ
- âœ… CSV/Excel ê°€ì ¸ì˜¤ê¸° ì •ìƒ ì‘ë™
- âœ… AI ê¸°ëŠ¥ ì •í™•ë„ 90% ì´ìƒ

**2. ì„±ëŠ¥ ì§€í‘œ**:
- âœ… ì¬ê³  í˜„í™© ì¡°íšŒ ì‘ë‹µ ì‹œê°„ < 500ms
- âœ… ëŒ€ì‹œë³´ë“œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ < 1ì´ˆ
- âœ… ì¼ì¼ ë¦¬í¬íŠ¸ ìƒì„± ì‹œê°„ < 5ì´ˆ
- âœ… AI íŒë‹¨ ì‘ë‹µ ì‹œê°„ < 5ì´ˆ

**3. ì‚¬ìš©ì„± ì§€í‘œ**:
- âœ… ì„¤ì¹˜ í›„ 30ë¶„ ë‚´ ì²« ë²ˆì§¸ ì¬ê³  ë¶„ì„ ê°€ëŠ¥
- âœ… ì‚¬ìš©ì ê°€ì´ë“œ ì™„ì„± (í•œê¸€, 50í˜ì´ì§€)
- âœ… ë‚´ë¶€ í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ë§Œì¡±ë„ 4.5/5 ì´ìƒ

**4. í’ˆì§ˆ ì§€í‘œ**:
- âœ… ìœ ë‹› í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ 90% ì´ìƒ
- âœ… E2E í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ 20ê°œ ì´ìƒ
- âœ… ì¹˜ëª…ì  ë²„ê·¸ 0ê±´
- âœ… ê²½ë¯¸í•œ ë²„ê·¸ < 5ê±´

**5. ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œ** (íŒŒì¼ëŸ¿ ê³ ê° 3ê°œì‚¬ ê¸°ì¤€):
- âœ… íê¸° ë¹„ìš© í‰ê·  60% ì´ìƒ ì ˆê°
- âœ… ë°œì£¼ ì •í™•ë„ í‰ê·  85% ì´ìƒ
- âœ… ì¬ê³  ê´€ë¦¬ ì—…ë¬´ ì‹œê°„ í‰ê·  70% ì´ìƒ ë‹¨ì¶•
- âœ… ROI (íˆ¬ì ëŒ€ë¹„ íš¨ê³¼) 6ê°œì›” ì´ë‚´ íšŒìˆ˜

---

## 1.4 í”„ë¡œì íŠ¸ ì¡°ì§ ë° ì—­í• 

### 1.4.1 AI ì—ì´ì „íŠ¸ íŒ€ êµ¬ì„±

ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆ ê°œë°œì—ëŠ” **TriFlow AIì˜ 18ê°œ AI ì—ì´ì „íŠ¸** ì¤‘ **Phase 1 í•µì‹¬ 8ê°œ ì—ì´ì „íŠ¸**ë¥¼ í™œìš©í•©ë‹ˆë‹¤:

| ì—ì´ì „íŠ¸ | ì—­í•  | ë‹´ë‹¹ ëª¨ë“ˆ |
|---------|------|----------|
| **ai-engineer** | AI ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ (íê¸° ìµœì†Œí™”, ì´ìƒ ê°ì§€) | ìœ í†µê¸°í•œ, ì•ˆì „ì¬ê³ , MRP |
| **prompt-engineer** | Claude API í”„ë¡¬í”„íŠ¸ ìµœì í™” | ì „ì²´ AI ê¸°ëŠ¥ |
| **database-optimization** | SQLite ìŠ¤í‚¤ë§ˆ ì„¤ê³„ + ì¿¼ë¦¬ ìµœì í™” | ì „ì²´ |
| **data-engineer** | MES/ERP ì—°ë™ + ë°ì´í„° íŒŒì´í”„ë¼ì¸ | ì „ì²´ |
| **graphql-architect** | MCP Connector API ì„¤ê³„ | MES/ERP ì—°ë™ |
| **business-analyst** | ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ + KPI ì„¤ê³„ | ë¹„ìš©ê´€ë¦¬, ë¦¬í¬íŠ¸, ëŒ€ì‹œë³´ë“œ |
| **task-decomposition-expert** | ë³µì¡í•œ ì›Œí¬í”Œë¡œìš° ë¶„í•´ | MRP, ìë™ë°œì£¼ì„œ |
| **search-specialist** | ë²¡í„° ê²€ìƒ‰ + RAG êµ¬í˜„ | ìœ ì‚¬ ì‚¬ë¡€ ê²€ìƒ‰ |

**Phase 2-3 ì§€ì› ì—ì´ì „íŠ¸** (í•„ìš”ì‹œ íˆ¬ì…):
- **frontend-architect**: UI/UX ê³ ë„í™”
- **performance-engineer**: ì„±ëŠ¥ ìµœì í™”
- **security-engineer**: ë°ì´í„° ì•”í˜¸í™”
- **technical-writer**: ì‚¬ìš©ì ê°€ì´ë“œ ì‘ì„±

### 1.4.2 ê°œë°œ í”„ë¡œì„¸ìŠ¤

**ì• ìì¼ ë°©ë²•ë¡ ** (2ì£¼ ìŠ¤í”„ë¦°íŠ¸):

```
Sprint 1-2 (Week 1-4): ê¸°ì´ˆ ì¸í”„ë¼ + ìœ í†µê¸°í•œ ëª¨ë“ˆ
Sprint 3-4 (Week 5-8): ì•ˆì „ì¬ê³  + MRP ëª¨ë“ˆ
Sprint 5-6 (Week 9-12): ìë™ë°œì£¼ì„œ + ë¹„ìš©ê´€ë¦¬ + ë¦¬í¬íŠ¸ + ëŒ€ì‹œë³´ë“œ
```

**ì¼ì¼ ì›Œí¬í”Œë¡œìš°**:
1. **09:00-09:30**: ì¼ì¼ ìŠ¤íƒ ë“œì—… (AI ì—ì´ì „íŠ¸ ìƒíƒœ í™•ì¸)
2. **09:30-12:00**: ê°œë°œ ì‘ì—… (ì—ì´ì „íŠ¸ë³„ ë³‘ë ¬ ì‘ì—…)
3. **12:00-13:00**: ì ì‹¬
4. **13:00-17:00**: ê°œë°œ + ì½”ë“œ ë¦¬ë·°
5. **17:00-18:00**: ì¼ì¼ íšŒê³  + TASKS.md ì—…ë°ì´íŠ¸

**Git ë¸Œëœì¹˜ ì „ëµ**:
```
main              # ì•ˆì • ë²„ì „ (íƒœê·¸ë§Œ)
develop           # ê°œë°œ ì¤‘ (ê¸°ë³¸ ë¸Œëœì¹˜)
feature/inventory-expiration   # ìœ í†µê¸°í•œ ëª¨ë“ˆ
feature/inventory-safety-stock # ì•ˆì „ì¬ê³  ëª¨ë“ˆ
feature/inventory-mrp          # MRP ëª¨ë“ˆ
...
```

### 1.4.3 ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ ê³„íš

**ë„êµ¬**:
- **TASKS.md**: ì „ì²´ ì§„í–‰ í˜„í™© ì¶”ì 
- **GitHub Issues**: ë²„ê·¸ ë° ê¸°ëŠ¥ ìš”ì²­
- **GitHub Projects**: ì¹¸ë°˜ ë³´ë“œ
- **Notion**: íšŒì˜ë¡ + ê¸°ìˆ  ë¬¸ì„œ
- **Slack**: ì‹¤ì‹œê°„ ì†Œí†µ (ì•Œë¦¼ ì—°ë™)

**ì£¼ê°„ ë³´ê³ **:
- **ì›”ìš”ì¼**: ì£¼ê°„ ê³„íš (ìŠ¤í”„ë¦°íŠ¸ ëª©í‘œ)
- **ê¸ˆìš”ì¼**: ì£¼ê°„ íšŒê³  (ì™„ë£Œìœ¨, ì´ìŠˆ, ë‹¤ìŒ ì£¼ ê³„íš)

---

**(ì„¹ì…˜ 1 ì¢…ë£Œ - ì´ ì•½ 300ì¤„)**

**ë‹¤ìŒ ì„¹ì…˜ ì˜ˆê³ **:
- **ì„¹ì…˜ 2**: ê¸°ìˆ  ìŠ¤íƒ ë° ì•„í‚¤í…ì²˜ (400ì¤„)
- **ì„¹ì…˜ 3**: 7ê°œ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„ (1,200ì¤„)
- **ì„¹ì…˜ 4**: ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„ (400ì¤„)
- **ì„¹ì…˜ 5**: AI ê¸°ëŠ¥ êµ¬í˜„ ì „ëµ (300ì¤„)
- **ì„¹ì…˜ 6**: ë‹¨ê³„ë³„ ê°œë°œ ì¼ì • Phase 11-15 (300ì¤„)
- **ì„¹ì…˜ 7**: ìœ„í—˜ ê´€ë¦¬ ë° ëŒ€ì‘ ì „ëµ (200ì¤„)

---

# 2. ê¸°ìˆ  ìŠ¤íƒ ë° ì•„í‚¤í…ì²˜

## 2.1 ê¸°ìˆ  ìŠ¤íƒ ê°œìš”

### 2.1.1 Frontend ê¸°ìˆ  ìŠ¤íƒ

ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆì€ ê¸°ì¡´ TriFlow AI Desktop Appì˜ Frontend ê¸°ìˆ  ìŠ¤íƒì„ **100% ì¬ì‚¬ìš©**í•©ë‹ˆë‹¤:

| ë ˆì´ì–´ | ê¸°ìˆ  | ë²„ì „ | ìš©ë„ |
|--------|------|------|------|
| **UI í”„ë ˆì„ì›Œí¬** | React | 18.2.0 | ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ UI |
| **ì–¸ì–´** | TypeScript | 5.0+ | íƒ€ì… ì•ˆì „ì„± |
| **ë¹Œë“œ ë„êµ¬** | Vite | 5.0+ | ë¹ ë¥¸ ê°œë°œ ì„œë²„ + ë²ˆë“¤ë§ |
| **ìƒíƒœ ê´€ë¦¬** | Zustand | 4.4.0 | ê²½ëŸ‰ ì „ì—­ ìƒíƒœ ê´€ë¦¬ |
| **ë¼ìš°íŒ…** | React Router | 6.20.0 | í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ë¼ìš°íŒ… |
| **ìŠ¤íƒ€ì¼ë§** | Tailwind CSS | 3.4.0 | ìœ í‹¸ë¦¬í‹° ê¸°ë°˜ CSS |
| **ì°¨íŠ¸** | Recharts | 2.10.0 | ì¬ê³  í˜„í™© ì‹œê°í™” |
| **í¼ ê´€ë¦¬** | React Hook Form | 7.48.0 | íš¨ìœ¨ì  í¼ ì²˜ë¦¬ |
| **ë‚ ì§œ ì²˜ë¦¬** | date-fns | 3.0.0 | ìœ í†µê¸°í•œ ê³„ì‚° |
| **ì•„ì´ì½˜** | Lucide React | 0.294.0 | ì¼ê´€ëœ ì•„ì´ì½˜ ì‹œìŠ¤í…œ |
| **í…Œì´ë¸”** | TanStack Table | 8.11.0 | ê³ ì„±ëŠ¥ ë°ì´í„° í…Œì´ë¸” |
| **ì•Œë¦¼** | React Hot Toast | 2.4.1 | í† ìŠ¤íŠ¸ ì•Œë¦¼ |

**ì‹ ê·œ ì¶”ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬** (ì¬ê³  ëª¨ë“ˆ ì „ìš©):

| ë¼ì´ë¸ŒëŸ¬ë¦¬ | ë²„ì „ | ìš©ë„ |
|-----------|------|------|
| **react-dnd** | 16.0.1 | ë“œë˜ê·¸ì•¤ë“œë¡­ (ë°œì£¼ì„œ í’ˆëª© ì¶”ê°€) |
| **papaparse** | 5.4.1 | CSV íŒŒì‹± (Excel ê°€ì ¸ì˜¤ê¸°) |
| **xlsx** | 0.18.5 | Excel íŒŒì¼ ì½ê¸°/ì“°ê¸° |

### 2.1.2 Backend ê¸°ìˆ  ìŠ¤íƒ (Rust Tauri)

ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆì˜ BackendëŠ” **Tauri 1.x (Rust)**ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤:

| ë ˆì´ì–´ | ê¸°ìˆ  | ë²„ì „ | ìš©ë„ |
|--------|------|------|------|
| **ì•± í”„ë ˆì„ì›Œí¬** | Tauri | 1.5.4 | Desktop App ëŸ°íƒ€ì„ |
| **ì–¸ì–´** | Rust | 1.75+ | ì•ˆì „í•˜ê³  ë¹ ë¥¸ ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë° |
| **ë°ì´í„°ë² ì´ìŠ¤** | SQLite | 3.44.0 | ë¡œì»¬ ë°ì´í„° ì €ì¥ |
| **ORM** | SeaORM | 0.12.0 | Rustìš© ë¹„ë™ê¸° ORM |
| **ë¹„ë™ê¸° ëŸ°íƒ€ì„** | Tokio | 1.35.0 | ë¹„ë™ê¸° I/O |
| **HTTP í´ë¼ì´ì–¸íŠ¸** | Reqwest | 0.11.0 | MES/ERP API í˜¸ì¶œ |
| **JSON ì§ë ¬í™”** | Serde | 1.0.0 | JSON â†” Rust ë³€í™˜ |
| **ë‚ ì§œ/ì‹œê°„** | Chrono | 0.4.0 | ìœ í†µê¸°í•œ ê³„ì‚° |
| **ë¡œê¹…** | Tracing | 0.1.0 | êµ¬ì¡°í™” ë¡œê¹… |

**ì‹ ê·œ ì¶”ê°€ Crate** (ì¬ê³  ëª¨ë“ˆ ì „ìš©):

| Crate | ë²„ì „ | ìš©ë„ |
|-------|------|------|
| **csv** | 1.3.0 | CSV íŒŒì¼ ì½ê¸°/ì“°ê¸° |
| **calamine** | 0.22.0 | Excel íŒŒì¼ ì½ê¸° |
| **rust_xlsxwriter** | 0.53.0 | Excel íŒŒì¼ ì“°ê¸° |

### 2.1.3 AI ë° ë°ì´í„° ê¸°ìˆ  ìŠ¤íƒ

| ë ˆì´ì–´ | ê¸°ìˆ  | ë²„ì „ | ìš©ë„ |
|--------|------|------|------|
| **LLM API** | Claude API | 3.5 Sonnet | íê¸° ìµœì†Œí™”, ë°œì£¼ íƒ€ì´ë° ì¶”ì²œ |
| **ë²¡í„° ê²€ìƒ‰** | SQLite FTS5 | 3.44.0 | ê²½ëŸ‰ ì „ë¬¸ ê²€ìƒ‰ (pgvector ëŒ€ì²´) |
| **í†µê³„ ë¶„ì„** | statrs (Rust) | 0.16.0 | ì¬ê³  íšŒì „ìœ¨, ì´ìƒ ê°ì§€ |
| **ì„ë² ë”©** | Claude Embeddings | - | í…ìŠ¤íŠ¸ â†’ ë²¡í„° ë³€í™˜ (ìœ ì‚¬ ì‚¬ë¡€ ê²€ìƒ‰) |
| **ìºì‹±** | Memory Cache | - | Claude API ì‘ë‹µ ìºì‹± (24ì‹œê°„) |

### 2.1.4 ê°œë°œ ë° ë°°í¬ ë„êµ¬

| ë„êµ¬ | ë²„ì „ | ìš©ë„ |
|------|------|------|
| **íŒ¨í‚¤ì§€ ê´€ë¦¬** | npm | 10.2.0 | Frontend ì˜ì¡´ì„± |
| **íŒ¨í‚¤ì§€ ê´€ë¦¬** | Cargo | 1.75.0 | Rust ì˜ì¡´ì„± |
| **ë²„ì „ ê´€ë¦¬** | Git | 2.43.0 | ì†ŒìŠ¤ ì½”ë“œ ê´€ë¦¬ |
| **CI/CD** | GitHub Actions | - | ìë™ ë¹Œë“œ + í…ŒìŠ¤íŠ¸ |
| **ì¸ìŠ¤í†¨ëŸ¬** | NSIS | - | Windows ì„¤ì¹˜ í”„ë¡œê·¸ë¨ |
| **í…ŒìŠ¤íŠ¸** | Vitest | 1.0.4 | Frontend ìœ ë‹› í…ŒìŠ¤íŠ¸ |
| **í…ŒìŠ¤íŠ¸** | Cargo Test | - | Rust ìœ ë‹› í…ŒìŠ¤íŠ¸ |
| **E2E í…ŒìŠ¤íŠ¸** | Playwright | 1.40.0 | í†µí•© í…ŒìŠ¤íŠ¸ |
| **ì½”ë“œ í’ˆì§ˆ** | ESLint | 8.55.0 | TypeScript ë¦°íŒ… |
| **ì½”ë“œ í’ˆì§ˆ** | Clippy | - | Rust ë¦°íŒ… |
| **í¬ë§¤íŒ…** | Prettier | 3.1.0 | TypeScript í¬ë§¤íŒ… |
| **í¬ë§¤íŒ…** | Rustfmt | - | Rust í¬ë§¤íŒ… |

## 2.2 ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.2.1 ë ˆì´ì–´ ì•„í‚¤í…ì²˜

ì¬ê³  ê´€ë¦¬ ëª¨ë“ˆì€ **3-Tier ì•„í‚¤í…ì²˜**ë¥¼ ë”°ë¦…ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Presentation Layer                      â”‚
â”‚         (React + TypeScript + Tailwind CSS)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ìœ í†µê¸°í•œ  â”‚  â”‚ ì•ˆì „ì¬ê³   â”‚  â”‚   MRP    â”‚  â”‚ ë°œì£¼ì„œ  â”‚ â”‚
â”‚  â”‚   ê´€ë¦¬   â”‚  â”‚          â”‚  â”‚          â”‚  â”‚        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ë¹„ìš©ê´€ë¦¬  â”‚  â”‚   ë¦¬í¬íŠ¸  â”‚  â”‚      ëŒ€ì‹œë³´ë“œ        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†• Tauri IPC (invoke)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Business Layer                         â”‚
â”‚                  (Rust + Tauri)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Inventory Service â”‚  â”‚   MES/ERP Connector    â”‚     â”‚
â”‚  â”‚  - CRUD ì‘ì—…       â”‚  â”‚   - API í˜¸ì¶œ           â”‚     â”‚
â”‚  â”‚  - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§    â”‚  â”‚   - ë°ì´í„° ë™ê¸°í™”       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   AI Service       â”‚  â”‚  Calculation Service   â”‚     â”‚
â”‚  â”‚  - Claude API      â”‚  â”‚  - ì•ˆì „ì¬ê³  ê³„ì‚°        â”‚     â”‚
â”‚  â”‚  - ì„ë² ë”©/RAG      â”‚  â”‚  - MRP ë¶„ì„            â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†• SeaORM
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Data Layer                             â”‚
â”‚                  (SQLite 3.44.0)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ inventory_items â”‚  â”‚ inventory_transactions      â”‚   â”‚
â”‚  â”‚ (í’ˆëª© ë§ˆìŠ¤í„°)    â”‚  â”‚ (ì…ì¶œê³  ê±°ë˜)                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ safety_stock    â”‚  â”‚ expiration_tracking         â”‚   â”‚
â”‚  â”‚ (ì•ˆì „ì¬ê³  ì„¤ì •) â”‚  â”‚ (ìœ í†µê¸°í•œ ì¶”ì )              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ purchase_orders â”‚  â”‚ material_costs              â”‚   â”‚
â”‚  â”‚ (ë°œì£¼ì„œ)        â”‚  â”‚ (ì›ìì¬ ë¹„ìš©)                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2.2 ì»´í¬ë„ŒíŠ¸ ì•„í‚¤í…ì²˜ (Frontend)

```
src/
â”œâ”€â”€ pages/                    # í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ InventoryHome.tsx     # ì¬ê³  ê´€ë¦¬ í™ˆ
â”‚   â”œâ”€â”€ ExpirationManagement.tsx  # ìœ í†µê¸°í•œ ê´€ë¦¬
â”‚   â”œâ”€â”€ SafetyStock.tsx       # ì•ˆì „ì¬ê³ 
â”‚   â”œâ”€â”€ MRP.tsx               # MRP
â”‚   â”œâ”€â”€ PurchaseOrder.tsx     # ìë™ë°œì£¼ì„œ
â”‚   â”œâ”€â”€ CostManagement.tsx    # ë¹„ìš©ê´€ë¦¬
â”‚   â”œâ”€â”€ DailyReport.tsx       # ì¼ì¼ ë¦¬í¬íŠ¸
â”‚   â””â”€â”€ InventoryDashboard.tsx # ëŒ€ì‹œë³´ë“œ
â”‚
â”œâ”€â”€ components/inventory/     # ì¬ê³  ì „ìš© ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ ExpirationTimeline.tsx    # ìœ í†µê¸°í•œ íƒ€ì„ë¼ì¸
â”‚   â”œâ”€â”€ SafetyStockGauge.tsx      # ì•ˆì „ì¬ê³  ê²Œì´ì§€
â”‚   â”œâ”€â”€ MRPAnalysisChart.tsx      # MRP ë¶„ì„ ì°¨íŠ¸
â”‚   â”œâ”€â”€ PurchaseOrderForm.tsx     # ë°œì£¼ì„œ í¼
â”‚   â”œâ”€â”€ CostTrendChart.tsx        # ë¹„ìš© ì¶”ì´ ì°¨íŠ¸
â”‚   â”œâ”€â”€ InventoryHeatmap.tsx      # ì¬ê³  íˆíŠ¸ë§µ
â”‚   â”œâ”€â”€ ItemSelector.tsx          # í’ˆëª© ì„ íƒê¸°
â”‚   â”œâ”€â”€ TransactionTable.tsx      # ê±°ë˜ ë‚´ì—­ í…Œì´ë¸”
â”‚   â””â”€â”€ StockAlert.tsx            # ì¬ê³  ì•Œë¦¼ ë°°ì§€
â”‚
â”œâ”€â”€ stores/                   # Zustand ìƒíƒœ ê´€ë¦¬
â”‚   â”œâ”€â”€ inventoryStore.ts     # ì¬ê³  í˜„í™© ìƒíƒœ
â”‚   â”œâ”€â”€ expirationStore.ts    # ìœ í†µê¸°í•œ ìƒíƒœ
â”‚   â”œâ”€â”€ safetyStockStore.ts   # ì•ˆì „ì¬ê³  ìƒíƒœ
â”‚   â””â”€â”€ purchaseOrderStore.ts # ë°œì£¼ì„œ ìƒíƒœ
â”‚
â”œâ”€â”€ services/                 # API í˜¸ì¶œ ë ˆì´ì–´
â”‚   â”œâ”€â”€ inventoryService.ts   # ì¬ê³  CRUD
â”‚   â”œâ”€â”€ mesService.ts         # MES/ERP ì—°ë™
â”‚   â”œâ”€â”€ aiService.ts          # Claude API
â”‚   â””â”€â”€ reportService.ts      # ë¦¬í¬íŠ¸ ìƒì„±
â”‚
â”œâ”€â”€ hooks/                    # ì»¤ìŠ¤í…€ í›…
â”‚   â”œâ”€â”€ useInventory.ts       # ì¬ê³  ë°ì´í„° í›…
â”‚   â”œâ”€â”€ useExpiration.ts      # ìœ í†µê¸°í•œ í›…
â”‚   â”œâ”€â”€ useSafetyStock.ts     # ì•ˆì „ì¬ê³  í›…
â”‚   â””â”€â”€ usePurchaseOrder.ts   # ë°œì£¼ì„œ í›…
â”‚
â””â”€â”€ types/                    # TypeScript íƒ€ì… ì •ì˜
    â”œâ”€â”€ inventory.ts          # ì¬ê³  ê´€ë ¨ íƒ€ì…
    â”œâ”€â”€ mes.ts                # MES/ERP íƒ€ì…
    â””â”€â”€ ai.ts                 # AI ì‘ë‹µ íƒ€ì…
```

### 2.2.3 ëª¨ë“ˆ ì•„í‚¤í…ì²˜ (Rust Backend)

```
src-tauri/src/
â”œâ”€â”€ inventory/                # ì¬ê³  ëª¨ë“ˆ
â”‚   â”œâ”€â”€ mod.rs                # ëª¨ë“ˆ ë£¨íŠ¸
â”‚   â”œâ”€â”€ models.rs             # ë°ì´í„° ëª¨ë¸ (SeaORM Entity)
â”‚   â”œâ”€â”€ service.rs            # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”œâ”€â”€ commands.rs           # Tauri Command í•¸ë“¤ëŸ¬
â”‚   â””â”€â”€ calculations.rs       # ì•ˆì „ì¬ê³ , MRP ê³„ì‚° ë¡œì§
â”‚
â”œâ”€â”€ mes/                      # MES/ERP ì—°ë™
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ connector.rs          # MCP Connector
â”‚   â”œâ”€â”€ rest_client.rs        # REST API í´ë¼ì´ì–¸íŠ¸
â”‚   â”œâ”€â”€ sync_scheduler.rs     # ìë™ ë™ê¸°í™” ìŠ¤ì¼€ì¤„ëŸ¬
â”‚   â””â”€â”€ csv_importer.rs       # CSV ê°€ì ¸ì˜¤ê¸°
â”‚
â”œâ”€â”€ ai/                       # AI ê¸°ëŠ¥
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ claude_client.rs      # Claude API í´ë¼ì´ì–¸íŠ¸
â”‚   â”œâ”€â”€ embeddings.rs         # ì„ë² ë”© ìƒì„±
â”‚   â”œâ”€â”€ vector_search.rs      # SQLite FTS5 ë²¡í„° ê²€ìƒ‰
â”‚   â””â”€â”€ cache.rs              # AI ì‘ë‹µ ìºì‹±
â”‚
â”œâ”€â”€ reports/                  # ë¦¬í¬íŠ¸ ìƒì„±
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ daily_report.rs       # ì¼ì¼ ë¦¬í¬íŠ¸
â”‚   â”œâ”€â”€ excel_exporter.rs     # Excel ë‚´ë³´ë‚´ê¸°
â”‚   â””â”€â”€ pdf_generator.rs      # PDF ìƒì„± (í–¥í›„)
â”‚
â””â”€â”€ database/                 # ë°ì´í„°ë² ì´ìŠ¤
    â”œâ”€â”€ mod.rs
    â”œâ”€â”€ connection.rs         # SQLite ì—°ê²° í’€
    â”œâ”€â”€ migrations/           # ìŠ¤í‚¤ë§ˆ ë§ˆì´ê·¸ë ˆì´ì…˜
    â”‚   â””â”€â”€ m20231118_inventory.rs
    â””â”€â”€ repository.rs         # ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´
```

### 2.2.4 ë°ì´í„° íë¦„ ì•„í‚¤í…ì²˜

**ì‹œë‚˜ë¦¬ì˜¤ 1: ì¬ê³  í˜„í™© ì¡°íšŒ**

```
User (Frontend)
  â†“ 1. í˜ì´ì§€ ë¡œë“œ
  â†“ 2. useInventory() í›… ì‹¤í–‰
  â†“ 3. inventoryService.getItems()
  â†“ 4. invoke('get_inventory_items') [Tauri IPC]
Rust Backend
  â†“ 5. commands::get_inventory_items()
  â†“ 6. service::get_all_items()
  â†“ 7. repository::find_all()
SQLite
  â†“ 8. SELECT * FROM inventory_items
  â† 9. ë°ì´í„° ë°˜í™˜
Rust Backend
  â† 10. JSON ì§ë ¬í™”
Frontend
  â† 11. ìƒíƒœ ì—…ë°ì´íŠ¸ (Zustand)
  â† 12. UI ë Œë”ë§
```

**ì‹œë‚˜ë¦¬ì˜¤ 2: MES/ERP ë™ê¸°í™” (ìë™)**

```
[5ë¶„ë§ˆë‹¤ ìë™ ì‹¤í–‰]
Rust Backend (Background Task)
  â†“ 1. sync_scheduler.rs ì‹¤í–‰
  â†“ 2. connector.fetch_inventory()
MES/ERP API
  â†“ 3. GET /api/v1/inventory
  â† 4. JSON ì‘ë‹µ (100ê°œ í’ˆëª©)
Rust Backend
  â†“ 5. ë°ì´í„° íŒŒì‹±
  â†“ 6. repository::upsert_items()
SQLite
  â†“ 7. INSERT OR REPLACE INTO inventory_items
  â† 8. ì—…ë°ì´íŠ¸ ì™„ë£Œ
Frontend (WebSocket)
  â† 9. ì‹¤ì‹œê°„ ì•Œë¦¼: "ì¬ê³  100ê±´ ë™ê¸°í™” ì™„ë£Œ"
```

**ì‹œë‚˜ë¦¬ì˜¤ 3: AI ê¸°ë°˜ íê¸° ìµœì†Œí™” ì¶”ì²œ**

```
User (Frontend)
  â†“ 1. "íê¸° ìµœì†Œí™” ì „ëµ ì¶”ì²œ" ë²„íŠ¼ í´ë¦­
  â†“ 2. aiService.getWasteReduction()
  â†“ 3. invoke('ai_waste_reduction') [Tauri IPC]
Rust Backend
  â†“ 4. ai::get_waste_reduction()
  â†“ 5. ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© ì¡°íšŒ (SQLite)
  â†“ 6. ì„ë² ë”© ìƒì„± (í˜„ì¬ ìƒí™©)
  â†“ 7. vector_search::find_similar_cases()
SQLite FTS5
  â†“ 8. ìœ ì‚¬ ì‚¬ë¡€ ê²€ìƒ‰ (10ê±´)
  â† 9. ê³¼ê±° ì„±ê³µ ì‚¬ë¡€ ë°˜í™˜
Rust Backend
  â†“ 10. claude_client::chat()
Claude API
  â†“ 11. í”„ë¡¬í”„íŠ¸ ì „ì†¡
  â”‚     - í˜„ì¬ ìƒí™©: ìœ í†µê¸°í•œ 7ì¼ ë‚¨ì€ í’ˆëª© 50ê°œ
  â”‚     - ìœ ì‚¬ ì‚¬ë¡€: ê³¼ê±° 10ê±´
  â”‚     - ì§ˆë¬¸: íê¸° ìµœì†Œí™” ì „ëµ 3ê°€ì§€ ì¶”ì²œ
  â† 12. AI ì‘ë‹µ
  â”‚     1. ìš°ì„ ì†Œë¹„ í’ˆëª© ë¦¬ìŠ¤íŠ¸ (30ê°œ)
  â”‚     2. í• ì¸ íŒë§¤ ì œì•ˆ (15ê°œ)
  â”‚     3. ê³µì • ìˆœì„œ ë³€ê²½ (5ê°œ)
Rust Backend
  â†“ 13. ì‘ë‹µ ìºì‹± (24ì‹œê°„)
Frontend
  â† 14. UIì— í‘œì‹œ
```

### 2.2.5 ë³´ì•ˆ ì•„í‚¤í…ì²˜

**ë°ì´í„° ë³´ì•ˆ**:

| ë ˆì´ì–´ | ë³´ì•ˆ ì¡°ì¹˜ |
|--------|----------|
| **Frontend â†’ Backend** | Tauri IPC (í”„ë¡œì„¸ìŠ¤ ë‚´ë¶€ í†µì‹ , ì™¸ë¶€ ì ‘ê·¼ ë¶ˆê°€) |
| **Backend â†’ MES/ERP** | HTTPS + Bearer Token (í™˜ê²½ ë³€ìˆ˜ ì €ì¥) |
| **Backend â†’ Claude API** | HTTPS + API Key (í™˜ê²½ ë³€ìˆ˜ ì €ì¥) |
| **SQLite ë°ì´í„°** | ì•”í˜¸í™” ì˜µì…˜ ì œê³µ (SQLCipher í†µí•© ê°€ëŠ¥) |
| **ë¯¼ê° ì •ë³´** | API Key, Tokenì€ `.env` íŒŒì¼ (Git ì œì™¸) |

**ì¸ì¦ ë° ê¶Œí•œ**:

```rust
// src-tauri/src/auth/mod.rs

pub struct AuthManager {
    // Desktop Appì€ ë‹¨ì¼ ì‚¬ìš©ìì´ë¯€ë¡œ ê°„ë‹¨í•œ PIN ì¸ì¦
    pin_hash: String,
}

impl AuthManager {
    pub fn verify_pin(&self, pin: &str) -> bool {
        // bcrypt í•´ì‹œ ê²€ì¦
        bcrypt::verify(pin, &self.pin_hash).unwrap_or(false)
    }

    pub fn require_auth() -> bool {
        // ì„¤ì •ì—ì„œ ì¸ì¦ í™œì„±í™” ì—¬ë¶€ í™•ì¸
        get_settings().auth_enabled
    }
}

// Tauri Command ì˜ˆì‹œ
#[tauri::command]
pub async fn delete_inventory_item(
    item_id: String,
    pin: Option<String>,
    state: State<'_, AppState>
) -> Result<(), String> {
    // ì¸ì¦ì´ í™œì„±í™”ëœ ê²½ìš° PIN ê²€ì¦
    if AuthManager::require_auth() {
        let pin = pin.ok_or("PIN required")?;
        if !state.auth.verify_pin(&pin) {
            return Err("Invalid PIN".to_string());
        }
    }

    // ì‚­ì œ ë¡œì§
    state.inventory_service.delete_item(&item_id).await?;
    Ok(())
}
```

## 2.3 ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 2.3.1 Frontend ì„±ëŠ¥ ìµœì í™”

**1. ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…**:

```typescript
// src/routes.tsx

import { lazy } from 'react';

// ì¬ê³  ëª¨ë“ˆì€ ë³„ë„ ì²­í¬ë¡œ ë¶„ë¦¬
const InventoryHome = lazy(() => import('./pages/InventoryHome'));
const ExpirationManagement = lazy(() => import('./pages/ExpirationManagement'));
const SafetyStock = lazy(() => import('./pages/SafetyStock'));
// ...

export const inventoryRoutes = [
  {
    path: '/inventory',
    element: <Suspense fallback={<Loading />}><InventoryHome /></Suspense>
  },
  // ...
];
```

**2. ê°€ìƒ ìŠ¤í¬ë¡¤ë§** (ëŒ€ìš©ëŸ‰ ë°ì´í„° í…Œì´ë¸”):

```typescript
// src/components/inventory/TransactionTable.tsx

import { useVirtualizer } from '@tanstack/react-virtual';

const TransactionTable = ({ transactions }: { transactions: Transaction[] }) => {
  const parentRef = useRef<HTMLDivElement>(null);

  const rowVirtualizer = useVirtualizer({
    count: transactions.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50, // í–‰ ë†’ì´
    overscan: 10 // ë²„í¼
  });

  return (
    <div ref={parentRef} style={{ height: '600px', overflow: 'auto' }}>
      <div style={{ height: `${rowVirtualizer.getTotalSize()}px` }}>
        {rowVirtualizer.getVirtualItems().map(virtualRow => (
          <div
            key={virtualRow.index}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualRow.size}px`,
              transform: `translateY(${virtualRow.start}px)`
            }}
          >
            {/* ê±°ë˜ ë‚´ì—­ í–‰ ë Œë”ë§ */}
            {transactions[virtualRow.index].itemName}
          </div>
        ))}
      </div>
    </div>
  );
};
```

**3. ë©”ëª¨ì´ì œì´ì…˜**:

```typescript
// src/hooks/useInventory.ts

import { useMemo } from 'react';

export const useInventory = () => {
  const items = useInventoryStore(state => state.items);

  // ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© ê³„ì‚° (ë¹„ìš©ì´ í° ì—°ì‚°)
  const expiringItems = useMemo(() => {
    const sevenDaysLater = addDays(new Date(), 7);
    return items.filter(item =>
      item.expirationDate &&
      isBefore(parseISO(item.expirationDate), sevenDaysLater)
    );
  }, [items]); // itemsê°€ ë³€ê²½ë  ë•Œë§Œ ì¬ê³„ì‚°

  return { items, expiringItems };
};
```

### 2.3.2 Backend ì„±ëŠ¥ ìµœì í™” (Rust)

**1. ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€**:

```rust
// src-tauri/src/database/connection.rs

use sqlx::sqlite::{SqlitePool, SqlitePoolOptions};

pub async fn create_pool(db_path: &str) -> Result<SqlitePool, sqlx::Error> {
    SqlitePoolOptions::new()
        .max_connections(5) // Desktop Appì´ë¯€ë¡œ 5ê°œë©´ ì¶©ë¶„
        .acquire_timeout(Duration::from_secs(3))
        .connect(db_path)
        .await
}
```

**2. ë°°ì¹˜ ì‚½ì…** (MES/ERP ë™ê¸°í™”):

```rust
// src-tauri/src/mes/sync_scheduler.rs

pub async fn sync_inventory(
    connector: &InventoryMCPConnector,
    pool: &SqlitePool
) -> Result<usize, Box<dyn Error>> {
    let items = connector.fetch_inventory().await?;

    // ë°°ì¹˜ ì‚½ì… (í•œ ë²ˆì— 100ê°œì”©)
    let mut tx = pool.begin().await?;
    for chunk in items.chunks(100) {
        let mut query_builder = QueryBuilder::new(
            "INSERT OR REPLACE INTO inventory_items (item_code, item_name, current_stock, unit_price, last_updated)"
        );

        query_builder.push_values(chunk, |mut b, item| {
            b.push_bind(&item.item_code)
             .push_bind(&item.item_name)
             .push_bind(item.current_stock)
             .push_bind(item.unit_price)
             .push_bind(&item.last_updated);
        });

        query_builder.build().execute(&mut *tx).await?;
    }
    tx.commit().await?;

    Ok(items.len())
}
```

**3. ë¹„ë™ê¸° ì²˜ë¦¬** (Claude API í˜¸ì¶œ):

```rust
// src-tauri/src/ai/claude_client.rs

use tokio::task;

pub async fn get_multiple_recommendations(
    items: Vec<InventoryItem>
) -> Result<Vec<Recommendation>, Box<dyn Error>> {
    // ì—¬ëŸ¬ í’ˆëª©ì— ëŒ€í•´ ë³‘ë ¬ë¡œ AI ì¶”ì²œ ìš”ì²­
    let tasks: Vec<_> = items.into_iter().map(|item| {
        task::spawn(async move {
            claude_api_call(&item).await
        })
    }).collect();

    // ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
    let results = futures::future::join_all(tasks).await;

    // ê²°ê³¼ ìˆ˜ì§‘
    results.into_iter()
        .filter_map(|r| r.ok().and_then(|r| r.ok()))
        .collect()
}
```

### 2.3.3 AI API ì„±ëŠ¥ ìµœì í™”

**1. ì‘ë‹µ ìºì‹±**:

```rust
// src-tauri/src/ai/cache.rs

use std::collections::HashMap;
use std::time::{Duration, Instant};

pub struct AICache {
    cache: HashMap<String, (String, Instant)>,
    ttl: Duration,
}

impl AICache {
    pub fn new() -> Self {
        Self {
            cache: HashMap::new(),
            ttl: Duration::from_secs(24 * 60 * 60), // 24ì‹œê°„
        }
    }

    pub fn get(&mut self, key: &str) -> Option<String> {
        if let Some((value, timestamp)) = self.cache.get(key) {
            if timestamp.elapsed() < self.ttl {
                return Some(value.clone());
            } else {
                // ë§Œë£Œëœ ìºì‹œ ì œê±°
                self.cache.remove(key);
            }
        }
        None
    }

    pub fn set(&mut self, key: String, value: String) {
        self.cache.insert(key, (value, Instant::now()));
    }

    pub fn generate_key(prompt: &str, context: &str) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(prompt);
        hasher.update(context);
        format!("{:x}", hasher.finalize())
    }
}
```

**2. ë°°ì¹˜ ìš”ì²­**:

```rust
// ì—¬ëŸ¬ í’ˆëª©ì„ í•œ ë²ˆì˜ API í˜¸ì¶œë¡œ ì²˜ë¦¬

pub async fn batch_waste_reduction(
    items: Vec<InventoryItem>
) -> Result<BatchRecommendation, Box<dyn Error>> {
    // í’ˆëª© ì •ë³´ë¥¼ í•˜ë‚˜ì˜ í”„ë¡¬í”„íŠ¸ë¡œ ê²°í•©
    let items_summary = items.iter()
        .map(|item| format!("{}: ìœ í†µê¸°í•œ {}ì¼, ì¬ê³  {}ê°œ", item.name, item.days_to_expiry, item.stock))
        .collect::<Vec<_>>()
        .join("\n");

    let prompt = format!(
        "ë‹¤ìŒ {}ê°œ í’ˆëª©ì— ëŒ€í•´ íê¸° ìµœì†Œí™” ì „ëµì„ ì¼ê´„ ì¶”ì²œí•´ì£¼ì„¸ìš”:\n{}",
        items.len(),
        items_summary
    );

    // ë‹¨ì¼ API í˜¸ì¶œ
    let response = claude_client.chat(prompt).await?;

    // ì‘ë‹µ íŒŒì‹± (í’ˆëª©ë³„ ì¶”ì²œ ë¶„ë¦¬)
    parse_batch_response(response, items.len())
}
```

**ëª©í‘œ ì„±ëŠ¥ ì§€í‘œ**:

| ì‘ì—… | ëª©í‘œ ì‹œê°„ | ìµœì í™” ì „ëµ |
|------|----------|-----------|
| ì¬ê³  í˜„í™© ì¡°íšŒ (1000ê±´) | < 500ms | ì¸ë±ìŠ¤, ì—°ê²° í’€ |
| CSV ê°€ì ¸ì˜¤ê¸° (5000ê±´) | < 3ì´ˆ | ë°°ì¹˜ ì‚½ì…, ìŠ¤íŠ¸ë¦¬ë° |
| AI íê¸° ìµœì†Œí™” ì¶”ì²œ | < 5ì´ˆ | ìºì‹±, ë°°ì¹˜ ìš”ì²­ |
| ì¼ì¼ ë¦¬í¬íŠ¸ ìƒì„± | < 5ì´ˆ | ë¯¸ë¦¬ ì§‘ê³„ëœ ë·° |
| MES/ERP ë™ê¸°í™” (500ê±´) | < 10ì´ˆ | ë°°ì¹˜ ì‚½ì…, ë¹„ë™ê¸° |

## 2.4 í™•ì¥ì„± ë° ìœ ì§€ë³´ìˆ˜ì„±

### 2.4.1 í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜ (í–¥í›„ í™•ì¥)

ì¬ê³  ëª¨ë“ˆì€ í–¥í›„ í™•ì¥ì„ ê³ ë ¤í•˜ì—¬ **í”ŒëŸ¬ê·¸ì¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜**ë¥¼ ì„¤ê³„í•©ë‹ˆë‹¤:

```rust
// src-tauri/src/inventory/plugin.rs

pub trait InventoryPlugin: Send + Sync {
    fn name(&self) -> &str;
    fn on_item_updated(&self, item: &InventoryItem);
    fn on_reorder_triggered(&self, order: &PurchaseOrder);
}

pub struct PluginManager {
    plugins: Vec<Box<dyn InventoryPlugin>>,
}

impl PluginManager {
    pub fn register(&mut self, plugin: Box<dyn InventoryPlugin>) {
        self.plugins.push(plugin);
    }

    pub fn notify_item_updated(&self, item: &InventoryItem) {
        for plugin in &self.plugins {
            plugin.on_item_updated(item);
        }
    }
}

// í”ŒëŸ¬ê·¸ì¸ ì˜ˆì‹œ: Slack ì•Œë¦¼
pub struct SlackNotificationPlugin {
    webhook_url: String,
}

impl InventoryPlugin for SlackNotificationPlugin {
    fn name(&self) -> &str {
        "Slack Notification"
    }

    fn on_reorder_triggered(&self, order: &PurchaseOrder) {
        // Slack ì›¹í›…ìœ¼ë¡œ ë°œì£¼ ì•Œë¦¼ ì „ì†¡
        tokio::spawn(async move {
            send_slack_message(&self.webhook_url, order).await;
        });
    }
}
```

### 2.4.2 ë²„ì „ ê´€ë¦¬ ì „ëµ

**ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜**:

```rust
// src-tauri/src/database/migrations/mod.rs

use sea_orm_migration::prelude::*;

pub struct Migrator;

#[async_trait::async_trait]
impl MigratorTrait for Migrator {
    fn migrations() -> Vec<Box<dyn MigrationTrait>> {
        vec![
            Box::new(m20231118_create_inventory_tables::Migration),
            Box::new(m20231125_add_expiration_tracking::Migration),
            Box::new(m20231202_add_safety_stock_settings::Migration),
            // í–¥í›„ ë§ˆì´ê·¸ë ˆì´ì…˜ ì¶”ê°€
        ]
    }
}

// ì•± ì‹œì‘ì‹œ ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜
pub async fn run_migrations(db: &DatabaseConnection) -> Result<(), DbErr> {
    Migrator::up(db, None).await
}
```

**API ë²„ì „ ê´€ë¦¬**:

```typescript
// src/services/inventoryService.ts

const API_VERSION = 'v1';

export const inventoryService = {
  async getItems(): Promise<InventoryItem[]> {
    return invoke(`${API_VERSION}_get_inventory_items`);
  },

  // v2 API ì¶”ê°€ì‹œ
  async getItemsV2(): Promise<InventoryItemV2[]> {
    return invoke('v2_get_inventory_items');
  }
};
```

### 2.4.3 í…ŒìŠ¤íŠ¸ ì „ëµ

**ìœ ë‹› í…ŒìŠ¤íŠ¸ (Frontend)**:

```typescript
// src/components/inventory/SafetyStockGauge.test.tsx

import { render, screen } from '@testing-library/react';
import { SafetyStockGauge } from './SafetyStockGauge';

describe('SafetyStockGauge', () => {
  it('should display normal status when stock is above safety level', () => {
    render(<SafetyStockGauge currentStock={150} safetyStock={100} />);
    expect(screen.getByText('ì •ìƒ')).toBeInTheDocument();
    expect(screen.getByRole('progressbar')).toHaveAttribute('aria-valuenow', '150');
  });

  it('should display warning status when stock is below safety level', () => {
    render(<SafetyStockGauge currentStock={80} safetyStock={100} />);
    expect(screen.getByText('ê²½ê³ ')).toBeInTheDocument();
    expect(screen.getByRole('alert')).toHaveTextContent('ì•ˆì „ì¬ê³  ë¯¸ë§Œ');
  });
});
```

**ìœ ë‹› í…ŒìŠ¤íŠ¸ (Rust)**:

```rust
// src-tauri/src/inventory/calculations.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_reorder_point() {
        let result = calculate_reorder_point(
            25.0,  // daily_usage
            7,     // lead_time_days
            100    // safety_stock
        );

        assert_eq!(result, 275); // (25 * 7) + 100
    }

    #[test]
    fn test_calculate_economic_order_quantity() {
        let result = calculate_eoq(
            10000.0, // annual_demand
            50.0,    // ordering_cost
            2.0      // holding_cost
        );

        assert_eq!(result, 707); // sqrt((2 * 10000 * 50) / 2)
    }
}
```

**í†µí•© í…ŒìŠ¤íŠ¸ (E2E)**:

```typescript
// e2e/inventory/expiration-management.spec.ts

import { test, expect } from '@playwright/test';

test('ìœ í†µê¸°í•œ ê´€ë¦¬ - ì„ë°• í’ˆëª© í™•ì¸', async ({ page }) => {
  await page.goto('/inventory/expiration');

  // ìœ í†µê¸°í•œ 7ì¼ ì´ë‚´ í’ˆëª© í•„í„°ë§
  await page.click('button:has-text("7ì¼ ì´ë‚´")');

  // í…Œì´ë¸”ì— í‘œì‹œë˜ëŠ”ì§€ í™•ì¸
  const table = page.locator('table');
  await expect(table).toBeVisible();

  // ì²« ë²ˆì§¸ í–‰ í´ë¦­
  await page.click('table tbody tr:first-child');

  // ìƒì„¸ ì •ë³´ ëª¨ë‹¬ í‘œì‹œ í™•ì¸
  await expect(page.locator('div[role="dialog"]')).toBeVisible();
  await expect(page.locator('h2:has-text("í’ˆëª© ìƒì„¸")')).toBeVisible();
});

test('ìë™ ë°œì£¼ì„œ ìƒì„±', async ({ page }) => {
  await page.goto('/inventory/purchase-order');

  // ì¬ì£¼ë¬¸ í•„ìš” í’ˆëª© ìë™ ì„ íƒ
  await page.click('button:has-text("ì¬ì£¼ë¬¸ í•„ìš” í’ˆëª© ìë™ ì¶”ê°€")');

  // í’ˆëª© ê°œìˆ˜ í™•ì¸
  const itemCount = await page.locator('table tbody tr').count();
  expect(itemCount).toBeGreaterThan(0);

  // ë°œì£¼ì„œ ìƒì„±
  await page.click('button:has-text("ë°œì£¼ì„œ ìƒì„±")');

  // ì„±ê³µ ì•Œë¦¼ í™•ì¸
  await expect(page.locator('div:has-text("ë°œì£¼ì„œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤")')).toBeVisible();
});
```

---

**(ì„¹ì…˜ 2 ì¢…ë£Œ - ì•½ 450ì¤„)**

**ë‹¤ìŒ ì„¹ì…˜ ì˜ˆê³ **:
- **ì„¹ì…˜ 3**: 7ê°œ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„ (1,200ì¤„) - ê° ëª¨ë“ˆë‹¹ ì•½ 170ì¤„
- **ì„¹ì…˜ 4**: ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„ (400ì¤„)
- **ì„¹ì…˜ 5**: AI ê¸°ëŠ¥ êµ¬í˜„ ì „ëµ (300ì¤„)
- **ì„¹ì…˜ 6**: ë‹¨ê³„ë³„ ê°œë°œ ì¼ì • Phase 11-15 (300ì¤„)
- **ì„¹ì…˜ 7**: ìœ„í—˜ ê´€ë¦¬ ë° ëŒ€ì‘ ì „ëµ (200ì¤„)

# 3. 7ê°œ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„

## 3.1 ìœ í†µê¸°í•œ ê´€ë¦¬ ëª¨ë“ˆ (Expiration Management)

### 3.1.1 ëª¨ë“ˆ ê°œìš”

**ëª©ì **: ìœ í†µê¸°í•œ ì„ë°• í’ˆëª©ì„ ì¶”ì í•˜ê³  íê¸° ìµœì†Œí™”ë¥¼ ìœ„í•œ AI ê¸°ë°˜ ìš°ì„ ì†Œë¹„ ì „ëµ ì œê³µ

**í•µì‹¬ ê¸°ëŠ¥**:
1. ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© ìë™ ê°ì§€ (7ì¼/14ì¼/30ì¼ ì´ë‚´)
2. ìš°ì„ ì†Œë¹„ í’ˆëª© ì¶”ì²œ (AI ê¸°ë°˜)
3. ìœ ì‚¬ ìœ í†µê¸°í•œ í’ˆëª© ê·¸ë£¹í•‘
4. íê¸° ìµœì†Œí™” ì•Œê³ ë¦¬ì¦˜
5. ìœ í†µê¸°í•œ ì•Œë¦¼ (Desktop Notification)

### 3.1.2 ë°ì´í„° ëª¨ë¸

```rust
// src-tauri/src/inventory/models.rs

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "expiration_tracking")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: String,

    pub item_id: String,           // í’ˆëª© ID (FK)
    pub item_name: String,         // í’ˆëª©ëª…
    pub batch_number: String,      // ë¡œíŠ¸ ë²ˆí˜¸
    pub manufacture_date: String,  // ì œì¡°ì¼ (ISO 8601)
    pub expiration_date: String,   // ìœ í†µê¸°í•œ (ISO 8601)
    pub quantity: i32,             // ìˆ˜ëŸ‰
    pub location: String,          // ë³´ê´€ ìœ„ì¹˜
    pub days_to_expiry: i32,       // ë‚¨ì€ ì¼ìˆ˜ (ê³„ì‚° í•„ë“œ)
    pub priority_level: String,    // ìš°ì„ ìˆœìœ„ (critical/warning/normal)
    pub recommended_action: Option<String>, // AI ì¶”ì²œ ì¡°ì¹˜
    pub is_consumed: bool,         // ì†Œì§„ ì—¬ë¶€
    pub consumed_date: Option<String>, // ì†Œì§„ì¼
    pub created_at: String,        // ìƒì„±ì¼
    pub updated_at: String,        // ìˆ˜ì •ì¼
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::inventory_items::Entity",
        from = "Column::ItemId",
        to = "super::inventory_items::Column::Id"
    )]
    InventoryItem,
}
```

**TypeScript íƒ€ì… ì •ì˜**:

```typescript
// src/types/inventory.ts

export interface ExpirationTracking {
  id: string;
  itemId: string;
  itemName: string;
  batchNumber: string;
  manufactureDate: string;
  expirationDate: string;
  quantity: number;
  location: string;
  daysToExpiry: number;
  priorityLevel: 'critical' | 'warning' | 'normal';
  recommendedAction?: string;
  isConsumed: boolean;
  consumedDate?: string;
  createdAt: string;
  updatedAt: string;
}

export interface ExpirationGroup {
  daysRange: string; // "0-7", "8-14", "15-30"
  items: ExpirationTracking[];
  totalQuantity: number;
  totalValue: number;
}

export interface WasteReductionStrategy {
  priorityItems: ExpirationTracking[]; // ìš°ì„ ì†Œë¹„ í’ˆëª©
  discountSuggestions: Array<{
    item: ExpirationTracking;
    suggestedDiscount: number; // í• ì¸ìœ¨ (%)
    expectedSales: number;
  }>;
  processChanges: Array<{
    item: ExpirationTracking;
    suggestion: string;
  }>;
  estimatedSavings: number; // ì˜ˆìƒ ì ˆê°ì•¡
}
```

### 3.1.3 í•µì‹¬ ì•Œê³ ë¦¬ì¦˜

**1. ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© ê°ì§€**:

```rust
// src-tauri/src/inventory/expiration_service.rs

use chrono::{DateTime, Utc, Duration};

pub struct ExpirationService {
    db: Arc<SqlitePool>,
}

impl ExpirationService {
    /// ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© ì¡°íšŒ
    pub async fn get_expiring_items(
        &self,
        threshold_days: i32
    ) -> Result<Vec<ExpirationTracking>, Box<dyn Error>> {
        let now = Utc::now();
        let threshold_date = now + Duration::days(threshold_days as i64);

        let items = sqlx::query_as!(
            ExpirationTracking,
            r#"
            SELECT
                id, item_id, item_name, batch_number,
                manufacture_date, expiration_date, quantity, location,
                julianday(expiration_date) - julianday('now') as days_to_expiry,
                CASE
                    WHEN julianday(expiration_date) - julianday('now') <= 7 THEN 'critical'
                    WHEN julianday(expiration_date) - julianday('now') <= 14 THEN 'warning'
                    ELSE 'normal'
                END as priority_level,
                recommended_action, is_consumed, consumed_date,
                created_at, updated_at
            FROM expiration_tracking
            WHERE
                is_consumed = 0
                AND date(expiration_date) <= date(?, '+' || ? || ' days')
            ORDER BY days_to_expiry ASC
            "#,
            now.to_rfc3339(),
            threshold_days
        )
        .fetch_all(&*self.db)
        .await?;

        Ok(items)
    }

    /// ìœ í†µê¸°í•œë³„ ê·¸ë£¹í•‘
    pub fn group_by_expiration(
        &self,
        items: Vec<ExpirationTracking>
    ) -> Vec<ExpirationGroup> {
        let mut groups: HashMap<String, Vec<ExpirationTracking>> = HashMap::new();

        for item in items {
            let range = match item.days_to_expiry {
                0..=7 => "0-7",
                8..=14 => "8-14",
                15..=30 => "15-30",
                _ => "31+"
            };

            groups.entry(range.to_string())
                .or_insert_with(Vec::new)
                .push(item);
        }

        groups.into_iter()
            .map(|(range, items)| {
                let total_quantity: i32 = items.iter().map(|i| i.quantity).sum();
                ExpirationGroup {
                    days_range: range,
                    total_quantity,
                    items,
                    total_value: 0.0 // ì¶”í›„ ê³„ì‚°
                }
            })
            .collect()
    }
}
```

**2. AI ê¸°ë°˜ íê¸° ìµœì†Œí™” ì „ëµ**:

```rust
// src-tauri/src/ai/waste_reduction.rs

use crate::ai::claude_client::ClaudeClient;

pub struct WasteReductionEngine {
    claude_client: Arc<ClaudeClient>,
    cache: Arc<Mutex<AICache>>,
}

impl WasteReductionEngine {
    /// íê¸° ìµœì†Œí™” ì „ëµ ìƒì„±
    pub async fn generate_strategy(
        &self,
        expiring_items: Vec<ExpirationTracking>
    ) -> Result<WasteReductionStrategy, Box<dyn Error>> {
        // 1. ìœ ì‚¬ ì‚¬ë¡€ ê²€ìƒ‰ (ê³¼ê±° ì„±ê³µ ì‚¬ë¡€)
        let similar_cases = self.find_similar_cases(&expiring_items).await?;

        // 2. Claude APIë¡œ ì „ëµ ìƒì„±
        let prompt = self.build_prompt(&expiring_items, &similar_cases);

        // 3. ìºì‹œ í™•ì¸
        let cache_key = AICache::generate_key(&prompt, "waste_reduction");
        if let Some(cached) = self.cache.lock().await.get(&cache_key) {
            return Ok(serde_json::from_str(&cached)?);
        }

        // 4. API í˜¸ì¶œ
        let response = self.claude_client.chat(
            "ì œì¡°ì—… ì¬ê³  ê´€ë¦¬ ì „ë¬¸ê°€",
            vec![
                Message {
                    role: "user",
                    content: prompt
                }
            ]
        ).await?;

        // 5. ì‘ë‹µ íŒŒì‹±
        let strategy = self.parse_strategy_response(&response, &expiring_items)?;

        // 6. ìºì‹±
        self.cache.lock().await.set(
            cache_key,
            serde_json::to_string(&strategy)?
        );

        Ok(strategy)
    }

    fn build_prompt(
        &self,
        items: &[ExpirationTracking],
        similar_cases: &[SimilarCase]
    ) -> String {
        let items_summary = items.iter()
            .map(|item| format!(
                "- {}: ìœ í†µê¸°í•œ {}ì¼ ë‚¨ìŒ, ì¬ê³  {}ê°œ, ë¡œíŠ¸ {}",
                item.item_name,
                item.days_to_expiry,
                item.quantity,
                item.batch_number
            ))
            .collect::<Vec<_>>()
            .join("\n");

        let cases_summary = similar_cases.iter()
            .map(|case| format!(
                "ì‚¬ë¡€ {}: {} â†’ ê²°ê³¼: {}",
                case.id,
                case.scenario,
                case.outcome
            ))
            .collect::<Vec<_>>()
            .join("\n");

        format!(
            r#"ì œì¡°ì—… ì¬ê³  ê´€ë¦¬ ì „ë¬¸ê°€ë¡œì„œ ë‹¤ìŒ ìƒí™©ì— ëŒ€í•´ íê¸° ìµœì†Œí™” ì „ëµì„ ì œì•ˆí•´ì£¼ì„¸ìš”.

## í˜„ì¬ ìƒí™©
ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© {}ê°œ:
{}

## ê³¼ê±° ìœ ì‚¬ ì‚¬ë¡€ (ì°¸ê³ ìš©)
{}

## ìš”ì²­ì‚¬í•­
ë‹¤ìŒ 3ê°€ì§€ ì „ëµì„ JSON í˜•ì‹ìœ¼ë¡œ ì œì•ˆí•´ì£¼ì„¸ìš”:

1. **ìš°ì„ ì†Œë¹„ í’ˆëª© ë¦¬ìŠ¤íŠ¸**: ì¦‰ì‹œ ê³µì •ì— íˆ¬ì…í•  í’ˆëª© (í’ˆëª©ëª…, ìˆ˜ëŸ‰, ì´ìœ )
2. **í• ì¸ íŒë§¤ ì œì•ˆ**: ì¬ê³  ì†Œì§„ì„ ìœ„í•œ í• ì¸ íŒë§¤ (í’ˆëª©ëª…, í• ì¸ìœ¨, ì˜ˆìƒ íŒë§¤ëŸ‰)
3. **ê³µì • ìˆœì„œ ë³€ê²½**: ìƒì‚° ê³µì • ì¡°ì • ì œì•ˆ (í’ˆëª©ëª…, ì œì•ˆ ë‚´ìš©)

ê° ì „ëµì˜ ì˜ˆìƒ ì ˆê°ì•¡ë„ ì‚°ì¶œí•´ì£¼ì„¸ìš”.

ì‘ë‹µ í˜•ì‹:
```json
{{
  "priorityItems": [
    {{"itemName": "...", "quantity": 100, "reason": "..."}}
  ],
  "discountSuggestions": [
    {{"itemName": "...", "discount": 15, "expectedSales": 80}}
  ],
  "processChanges": [
    {{"itemName": "...", "suggestion": "..."}}
  ],
  "estimatedSavings": 5000000
}}
```
"#,
            items.len(),
            items_summary,
            cases_summary
        )
    }

    fn parse_strategy_response(
        &self,
        response: &str,
        items: &[ExpirationTracking]
    ) -> Result<WasteReductionStrategy, Box<dyn Error>> {
        // JSON ì¶”ì¶œ (```json ... ``` ë¸”ë¡)
        let json_str = response
            .lines()
            .skip_while(|line| !line.contains("```json"))
            .skip(1)
            .take_while(|line| !line.contains("```"))
            .collect::<Vec<_>>()
            .join("\n");

        // JSON íŒŒì‹±
        let parsed: serde_json::Value = serde_json::from_str(&json_str)?;

        // WasteReductionStrategy êµ¬ì„±
        Ok(WasteReductionStrategy {
            priority_items: self.map_priority_items(&parsed, items)?,
            discount_suggestions: self.map_discount_suggestions(&parsed, items)?,
            process_changes: self.map_process_changes(&parsed, items)?,
            estimated_savings: parsed["estimatedSavings"].as_f64().unwrap_or(0.0)
        })
    }
}
```

### 3.1.4 UI ì»´í¬ë„ŒíŠ¸

**ìœ í†µê¸°í•œ íƒ€ì„ë¼ì¸**:

```typescript
// src/components/inventory/ExpirationTimeline.tsx

import { useMemo } from 'react';
import { format, addDays } from 'date-fns';
import { ko } from 'date-fns/locale';

interface ExpirationTimelineProps {
  items: ExpirationTracking[];
}

export const ExpirationTimeline: React.FC<ExpirationTimelineProps> = ({ items }) => {
  // ë‚ ì§œë³„ ê·¸ë£¹í•‘
  const timelineData = useMemo(() => {
    const today = new Date();
    const timeline: Record<string, ExpirationTracking[]> = {};

    for (let i = 0; i <= 30; i++) {
      const date = addDays(today, i);
      const dateKey = format(date, 'yyyy-MM-dd');
      timeline[dateKey] = [];
    }

    items.forEach(item => {
      const expiryDate = format(new Date(item.expirationDate), 'yyyy-MM-dd');
      if (timeline[expiryDate]) {
        timeline[expiryDate].push(item);
      }
    });

    return Object.entries(timeline).map(([date, items]) => ({
      date,
      items,
      count: items.length,
      totalQuantity: items.reduce((sum, item) => sum + item.quantity, 0)
    }));
  }, [items]);

  return (
    <div className="expiration-timeline">
      <h3>ìœ í†µê¸°í•œ íƒ€ì„ë¼ì¸ (30ì¼)</h3>
      <div className="timeline-container">
        {timelineData.map(({ date, items, count, totalQuantity }) => {
          const isToday = date === format(new Date(), 'yyyy-MM-dd');
          const hasItems = count > 0;

          return (
            <div
              key={date}
              className={`timeline-day ${isToday ? 'today' : ''} ${hasItems ? 'has-items' : ''}`}
            >
              <div className="date-label">
                {format(new Date(date), 'MM/dd (E)', { locale: ko })}
              </div>
              {hasItems && (
                <div className="items-badge" title={`${count}ê°œ í’ˆëª©, ì´ ${totalQuantity}ê°œ`}>
                  <span className="count">{count}</span>
                  <span className="quantity">{totalQuantity}</span>
                </div>
              )}
              {items.length > 0 && (
                <div className="items-list">
                  {items.map(item => (
                    <div key={item.id} className="item-chip" title={item.itemName}>
                      {item.itemName.substring(0, 10)}
                      {item.itemName.length > 10 && '...'}
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

**íê¸° ìµœì†Œí™” ì „ëµ íŒ¨ë„**:

```typescript
// src/components/inventory/WasteReductionPanel.tsx

import { useState } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { aiService } from '@/services/aiService';
import { toast } from 'react-hot-toast';

export const WasteReductionPanel: React.FC = () => {
  const [isGenerating, setIsGenerating] = useState(false);

  // ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© ì¡°íšŒ
  const { data: expiringItems } = useQuery({
    queryKey: ['expiringItems', 7],
    queryFn: () => inventoryService.getExpiringItems(7)
  });

  // AI ì „ëµ ìƒì„±
  const generateStrategy = useMutation({
    mutationFn: () => aiService.getWasteReductionStrategy(expiringItems || []),
    onSuccess: (strategy) => {
      toast.success('íê¸° ìµœì†Œí™” ì „ëµì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
      setStrategy(strategy);
    },
    onError: (error) => {
      toast.error(`ì „ëµ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }
  });

  const [strategy, setStrategy] = useState<WasteReductionStrategy | null>(null);

  return (
    <div className="waste-reduction-panel">
      <div className="header">
        <h3>íê¸° ìµœì†Œí™” ì „ëµ</h3>
        <button
          onClick={() => generateStrategy.mutate()}
          disabled={!expiringItems || expiringItems.length === 0 || isGenerating}
          className="btn-generate"
        >
          {isGenerating ? 'ìƒì„± ì¤‘...' : 'AI ì „ëµ ìƒì„±'}
        </button>
      </div>

      {strategy && (
        <div className="strategy-results">
          {/* 1. ìš°ì„ ì†Œë¹„ í’ˆëª© */}
          <section className="priority-items">
            <h4>ğŸ”¥ ìš°ì„ ì†Œë¹„ í’ˆëª© ({strategy.priorityItems.length}ê°œ)</h4>
            <table>
              <thead>
                <tr>
                  <th>í’ˆëª©ëª…</th>
                  <th>ìˆ˜ëŸ‰</th>
                  <th>ìœ í†µê¸°í•œ</th>
                  <th>ì´ìœ </th>
                </tr>
              </thead>
              <tbody>
                {strategy.priorityItems.map(item => (
                  <tr key={item.itemId}>
                    <td>{item.itemName}</td>
                    <td>{item.quantity}</td>
                    <td>{item.daysToExpiry}ì¼ ë‚¨ìŒ</td>
                    <td className="reason">{item.reason}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </section>

          {/* 2. í• ì¸ íŒë§¤ ì œì•ˆ */}
          <section className="discount-suggestions">
            <h4>ğŸ’° í• ì¸ íŒë§¤ ì œì•ˆ ({strategy.discountSuggestions.length}ê°œ)</h4>
            <div className="discount-cards">
              {strategy.discountSuggestions.map((suggestion, idx) => (
                <div key={idx} className="discount-card">
                  <div className="item-name">{suggestion.item.itemName}</div>
                  <div className="discount-rate">{suggestion.suggestedDiscount}% í• ì¸</div>
                  <div className="expected-sales">ì˜ˆìƒ íŒë§¤: {suggestion.expectedSales}ê°œ</div>
                </div>
              ))}
            </div>
          </section>

          {/* 3. ê³µì • ìˆœì„œ ë³€ê²½ */}
          <section className="process-changes">
            <h4>ğŸ”„ ê³µì • ìˆœì„œ ë³€ê²½ ì œì•ˆ ({strategy.processChanges.length}ê°œ)</h4>
            <ul>
              {strategy.processChanges.map((change, idx) => (
                <li key={idx}>
                  <strong>{change.item.itemName}</strong>: {change.suggestion}
                </li>
              ))}
            </ul>
          </section>

          {/* ì˜ˆìƒ ì ˆê°ì•¡ */}
          <div className="estimated-savings">
            <span className="label">ì˜ˆìƒ ì ˆê°ì•¡:</span>
            <span className="amount">{strategy.estimatedSavings.toLocaleString()}ì›</span>
          </div>
        </div>
      )}
    </div>
  );
};
```

### 3.1.5 ì•Œë¦¼ ì‹œìŠ¤í…œ

**Desktop Notification (Tauri)**:

```rust
// src-tauri/src/inventory/notifications.rs

use tauri::Manager;

pub struct NotificationManager {
    app_handle: tauri::AppHandle,
}

impl NotificationManager {
    pub fn new(app_handle: tauri::AppHandle) -> Self {
        Self { app_handle }
    }

    /// ìœ í†µê¸°í•œ ì„ë°• ì•Œë¦¼
    pub async fn notify_expiring_items(
        &self,
        items: &[ExpirationTracking]
    ) -> Result<(), Box<dyn Error>> {
        let critical_items: Vec<_> = items.iter()
            .filter(|item| item.priority_level == "critical")
            .collect();

        if critical_items.is_empty() {
            return Ok(());
        }

        let title = format!("âš ï¸ ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© {}ê°œ", critical_items.len());
        let body = critical_items.iter()
            .take(3)
            .map(|item| format!(
                "{}: {}ì¼ ë‚¨ìŒ ({}ê°œ)",
                item.item_name,
                item.days_to_expiry,
                item.quantity
            ))
            .collect::<Vec<_>>()
            .join("\n");

        // Tauri Notification
        self.app_handle.notification()
            .title(&title)
            .body(&body)
            .icon("icons/warning.png")
            .show()?;

        Ok(())
    }
}
```

### 3.1.6 ì„±ëŠ¥ ìµœì í™”

**ì¸ë±ìŠ¤ ì„¤ê³„**:

```sql
-- ìœ í†µê¸°í•œ ì¡°íšŒ ìµœì í™”
CREATE INDEX idx_expiration_date
ON expiration_tracking(expiration_date, is_consumed);

-- ìš°ì„ ìˆœìœ„ë³„ ì¡°íšŒ ìµœì í™”
CREATE INDEX idx_priority_level
ON expiration_tracking(priority_level, days_to_expiry);

-- í’ˆëª©ë³„ ì¡°íšŒ ìµœì í™”
CREATE INDEX idx_item_id
ON expiration_tracking(item_id, is_consumed);
```

**ìºì‹± ì „ëµ**:

```typescript
// src/hooks/useExpiration.ts

export const useExpiration = (thresholdDays: number = 7) => {
  return useQuery({
    queryKey: ['expiringItems', thresholdDays],
    queryFn: () => inventoryService.getExpiringItems(thresholdDays),
    staleTime: 5 * 60 * 1000, // 5ë¶„
    cacheTime: 10 * 60 * 1000, // 10ë¶„
    refetchInterval: 5 * 60 * 1000 // 5ë¶„ë§ˆë‹¤ ìë™ ê°±ì‹ 
  });
};
```

---

## 3.2 ì•ˆì „ì¬ê³  ëª¨ë“ˆ (Safety Stock Management)

### 3.2.1 ëª¨ë“ˆ ê°œìš”

**ëª©ì **: ìµœì  ì•ˆì „ì¬ê³  ìˆ˜ì¤€ ìœ ì§€ ë° ì¬ì£¼ë¬¸ì  ìë™ ê°ì§€

**í•µì‹¬ ê¸°ëŠ¥**:
1. ì•ˆì „ì¬ê³  ìˆ˜ì¤€ ìë™ ê³„ì‚° (í†µê³„ ê¸°ë°˜)
2. ì¬ì£¼ë¬¸ì  ë„ë‹¬ ìë™ ì•Œë¦¼
3. ë°œì£¼ëŸ‰ ìµœì í™” (EOQ ëª¨ë¸)
4. ì¬ê³  ì´ìƒ íŒ¨í„´ ê°ì§€ (AI)
5. ê³µê¸‰ì—…ì²´ ë¦¬ë“œíƒ€ì„ ê´€ë¦¬

### 3.2.2 ë°ì´í„° ëª¨ë¸

```rust
// src-tauri/src/inventory/models.rs

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "safety_stock_settings")]
pub struct SafetyStockModel {
    #[sea_orm(primary_key)]
    pub id: String,

    pub item_id: String,              // í’ˆëª© ID (FK)
    pub item_name: String,            // í’ˆëª©ëª…
    pub safety_stock_level: i32,      // ì•ˆì „ì¬ê³  ìˆ˜ì¤€
    pub reorder_point: i32,           // ì¬ì£¼ë¬¸ì 
    pub economic_order_quantity: i32, // ê²½ì œì  ë°œì£¼ëŸ‰ (EOQ)
    pub lead_time_days: i32,          // ë¦¬ë“œíƒ€ì„ (ì¼)
    pub daily_usage_avg: f64,         // ì¼ì¼ í‰ê·  ì‚¬ìš©ëŸ‰
    pub daily_usage_std: f64,         // ì¼ì¼ ì‚¬ìš©ëŸ‰ í‘œì¤€í¸ì°¨
    pub service_level: f64,           // ì„œë¹„ìŠ¤ ìˆ˜ì¤€ (0.95 = 95%)
    pub supplier_id: Option<String>,  // ê³µê¸‰ì—…ì²´ ID
    pub supplier_reliability: f64,    // ê³µê¸‰ì—…ì²´ ì‹ ë¢°ë„ (0.0-1.0)
    pub last_calculated_at: String,   // ë§ˆì§€ë§‰ ê³„ì‚°ì¼
    pub auto_reorder_enabled: bool,   // ìë™ ë°œì£¼ í™œì„±í™”
    pub created_at: String,
    pub updated_at: String,
}
```

**TypeScript íƒ€ì…**:

```typescript
export interface SafetyStockSettings {
  id: string;
  itemId: string;
  itemName: string;
  safetyStockLevel: number;
  reorderPoint: number;
  economicOrderQuantity: number;
  leadTimeDays: number;
  dailyUsageAvg: number;
  dailyUsageStd: number;
  serviceLevel: number;
  supplierId?: string;
  supplierReliability: number;
  lastCalculatedAt: string;
  autoReorderEnabled: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface ReorderAlert {
  item: SafetyStockSettings;
  currentStock: number;
  reorderPoint: number;
  deficit: number; // ë¶€ì¡±ëŸ‰
  urgencyLevel: 'high' | 'medium' | 'low';
  recommendedOrderQuantity: number;
  estimatedArrivalDate: string;
}
```

### 3.2.3 í•µì‹¬ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜

**1. ì•ˆì „ì¬ê³  ê³„ì‚° (í†µê³„ ê¸°ë°˜)**:

```rust
// src-tauri/src/inventory/calculations.rs

use statrs::distribution::{Normal, ContinuousCDF};

/// ì•ˆì „ì¬ê³  ê³„ì‚° (ì •ê·œë¶„í¬ ê°€ì •)
///
/// ê³µì‹: SS = Z Ã— Ïƒ_L Ã— âˆšL
/// - Z: ì„œë¹„ìŠ¤ ìˆ˜ì¤€ì— ëŒ€í•œ Z-score (95% â†’ 1.65)
/// - Ïƒ_L: ë¦¬ë“œíƒ€ì„ ë™ì•ˆì˜ ìˆ˜ìš” í‘œì¤€í¸ì°¨
/// - L: ë¦¬ë“œíƒ€ì„ (ì¼)
pub fn calculate_safety_stock(
    daily_usage_avg: f64,
    daily_usage_std: f64,
    lead_time_days: i32,
    service_level: f64 // 0.95 = 95%
) -> i32 {
    // Z-score ê³„ì‚° (ì •ê·œë¶„í¬)
    let normal = Normal::new(0.0, 1.0).unwrap();
    let z_score = normal.inverse_cdf(service_level);

    // ë¦¬ë“œíƒ€ì„ ë™ì•ˆì˜ ìˆ˜ìš” í‘œì¤€í¸ì°¨
    let lead_time_demand_std = daily_usage_std * (lead_time_days as f64).sqrt();

    // ì•ˆì „ì¬ê³  = Z Ã— Ïƒ_L
    let safety_stock = z_score * lead_time_demand_std;

    safety_stock.ceil() as i32
}

/// ì¬ì£¼ë¬¸ì  ê³„ì‚°
///
/// ê³µì‹: ROP = (ì¼ì¼ ì‚¬ìš©ëŸ‰ Ã— ë¦¬ë“œíƒ€ì„) + ì•ˆì „ì¬ê³ 
pub fn calculate_reorder_point(
    daily_usage_avg: f64,
    lead_time_days: i32,
    safety_stock: i32
) -> i32 {
    let lead_time_demand = daily_usage_avg * lead_time_days as f64;
    (lead_time_demand + safety_stock as f64).ceil() as i32
}

/// ê²½ì œì  ë°œì£¼ëŸ‰ (EOQ) ê³„ì‚°
///
/// ê³µì‹: EOQ = âˆš((2 Ã— D Ã— S) / H)
/// - D: ì—°ê°„ ìˆ˜ìš”ëŸ‰
/// - S: ë°œì£¼ ë¹„ìš©
/// - H: ë‹¨ìœ„ë‹¹ ì—°ê°„ ë³´ê´€ ë¹„ìš©
pub fn calculate_eoq(
    annual_demand: f64,
    ordering_cost: f64,
    holding_cost: f64
) -> i32 {
    let eoq = ((2.0 * annual_demand * ordering_cost) / holding_cost).sqrt();
    eoq.ceil() as i32
}
```

**2. ì¬ê³  ì´ìƒ íŒ¨í„´ ê°ì§€ (AI)**:

```rust
// src-tauri/src/ai/anomaly_detection.rs

pub struct AnomalyDetectionEngine {
    claude_client: Arc<ClaudeClient>,
}

impl AnomalyDetectionEngine {
    /// ì¬ê³  ì´ìƒ íŒ¨í„´ ê°ì§€
    pub async fn detect_anomalies(
        &self,
        item_id: &str,
        transaction_history: Vec<InventoryTransaction>
    ) -> Result<Vec<Anomaly>, Box<dyn Error>> {
        // 1. í†µê³„ì  ì´ìƒ ê°ì§€ (IQR ë°©ë²•)
        let statistical_anomalies = self.detect_statistical_anomalies(&transaction_history)?;

        // 2. AI ê¸°ë°˜ íŒ¨í„´ ì´ìƒ ê°ì§€
        let pattern_anomalies = self.detect_pattern_anomalies(
            item_id,
            &transaction_history
        ).await?;

        // 3. ê²°ê³¼ ê²°í•©
        let mut anomalies = statistical_anomalies;
        anomalies.extend(pattern_anomalies);

        Ok(anomalies)
    }

    fn detect_statistical_anomalies(
        &self,
        transactions: &[InventoryTransaction]
    ) -> Result<Vec<Anomaly>, Box<dyn Error>> {
        let quantities: Vec<f64> = transactions.iter()
            .map(|t| t.quantity as f64)
            .collect();

        // IQR (Interquartile Range) ê³„ì‚°
        let mut sorted = quantities.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());

        let n = sorted.len();
        let q1 = sorted[n / 4];
        let q3 = sorted[3 * n / 4];
        let iqr = q3 - q1;

        let lower_bound = q1 - 1.5 * iqr;
        let upper_bound = q3 + 1.5 * iqr;

        // ì´ìƒì¹˜ íƒì§€
        let anomalies: Vec<Anomaly> = transactions.iter()
            .enumerate()
            .filter_map(|(idx, tx)| {
                let qty = tx.quantity as f64;
                if qty < lower_bound || qty > upper_bound {
                    Some(Anomaly {
                        transaction_id: tx.id.clone(),
                        anomaly_type: "statistical_outlier",
                        severity: if qty < lower_bound { "low" } else { "high" },
                        description: format!(
                            "ë¹„ì •ìƒì ì¸ {}ëŸ‰ ê°ì§€: {}ê°œ (ì •ìƒ ë²”ìœ„: {:.0}-{:.0})",
                            if tx.transaction_type == "in" { "ì…ê³ " } else { "ì¶œê³ " },
                            qty,
                            lower_bound,
                            upper_bound
                        ),
                        detected_at: Utc::now().to_rfc3339()
                    })
                } else {
                    None
                }
            })
            .collect();

        Ok(anomalies)
    }

    async fn detect_pattern_anomalies(
        &self,
        item_id: &str,
        transactions: &[InventoryTransaction]
    ) -> Result<Vec<Anomaly>, Box<dyn Error>> {
        // Claude APIë¡œ íŒ¨í„´ ë¶„ì„
        let prompt = self.build_pattern_analysis_prompt(item_id, transactions);

        let response = self.claude_client.chat(
            "ì œì¡°ì—… ì¬ê³  ë¶„ì„ ì „ë¬¸ê°€",
            vec![Message { role: "user", content: prompt }]
        ).await?;

        // ì‘ë‹µ íŒŒì‹±
        self.parse_pattern_anomalies(&response)
    }

    fn build_pattern_analysis_prompt(
        &self,
        item_id: &str,
        transactions: &[InventoryTransaction]
    ) -> String {
        let tx_summary = transactions.iter()
            .take(30) // ìµœê·¼ 30ê±´
            .map(|tx| format!(
                "{}: {} {}ê°œ (ì¬ê³ : {})",
                tx.created_at,
                if tx.transaction_type == "in" { "ì…ê³ " } else { "ì¶œê³ " },
                tx.quantity,
                tx.stock_after
            ))
            .collect::<Vec<_>>()
            .join("\n");

        format!(
            r#"ë‹¤ìŒì€ í’ˆëª© {}ì˜ ìµœê·¼ 30ì¼ ì¬ê³  ê±°ë˜ ë‚´ì—­ì…ë‹ˆë‹¤.

{}

ì´ìƒ íŒ¨í„´ì´ ë°œê²¬ë˜ëŠ”ì§€ ë¶„ì„í•´ì£¼ì„¸ìš”:
1. ê¸‰ê²©í•œ ì¬ê³  ì¦ê°€/ê°ì†Œ
2. ë¹„ì •ìƒì ì¸ ì…ì¶œê³  íŒ¨í„´
3. ê³µê¸‰ ë¶ˆì•ˆì • ì‹ í˜¸
4. ìˆ˜ìš” ê¸‰ë³€ ì‹ í˜¸

ë°œê²¬ëœ ì´ìƒ íŒ¨í„´ì„ JSON í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•´ì£¼ì„¸ìš”:
```json
[
  {{
    "type": "sudden_spike",
    "severity": "high",
    "description": "12ì›” 15ì¼ ì…ê³ ëŸ‰ ê¸‰ì¦ (í‰ê·  ëŒ€ë¹„ 300% ì¦ê°€)"
  }}
]
```
"#,
            item_id,
            tx_summary
        )
    }
}
```

### 3.2.4 UI ì»´í¬ë„ŒíŠ¸

**ì•ˆì „ì¬ê³  ê²Œì´ì§€**:

```typescript
// src/components/inventory/SafetyStockGauge.tsx

import { useMemo } from 'react';
import { GaugeChart } from '@/components/charts/GaugeChart';

interface SafetyStockGaugeProps {
  currentStock: number;
  safetyStock: number;
  reorderPoint: number;
  maxStock?: number;
}

export const SafetyStockGauge: React.FC<SafetyStockGaugeProps> = ({
  currentStock,
  safetyStock,
  reorderPoint,
  maxStock = safetyStock * 3
}) => {
  const status = useMemo(() => {
    if (currentStock <= reorderPoint) {
      return { level: 'critical', label: 'ì¬ì£¼ë¬¸ í•„ìš”', color: '#ef4444' };
    } else if (currentStock <= safetyStock * 1.2) {
      return { level: 'warning', label: 'ê²½ê³ ', color: '#f59e0b' };
    } else {
      return { level: 'normal', label: 'ì •ìƒ', color: '#10b981' };
    }
  }, [currentStock, reorderPoint, safetyStock]);

  const percentage = Math.min((currentStock / maxStock) * 100, 100);

  return (
    <div className="safety-stock-gauge">
      <GaugeChart
        value={currentStock}
        max={maxStock}
        segments={[
          { threshold: reorderPoint, color: '#ef4444', label: 'ì¬ì£¼ë¬¸ì ' },
          { threshold: safetyStock, color: '#f59e0b', label: 'ì•ˆì „ì¬ê³ ' },
          { threshold: maxStock, color: '#10b981', label: 'ì •ìƒ' }
        ]}
      />

      <div className="gauge-info">
        <div className="current-stock">
          <span className="label">í˜„ì¬ ì¬ê³ :</span>
          <span className="value" style={{ color: status.color }}>
            {currentStock.toLocaleString()}ê°œ
          </span>
        </div>

        <div className="reference-lines">
          <div className="line">
            <span className="label">ì¬ì£¼ë¬¸ì :</span>
            <span className="value">{reorderPoint.toLocaleString()}ê°œ</span>
          </div>
          <div className="line">
            <span className="label">ì•ˆì „ì¬ê³ :</span>
            <span className="value">{safetyStock.toLocaleString()}ê°œ</span>
          </div>
        </div>

        <div className={`status-badge ${status.level}`}>
          {status.label}
        </div>
      </div>
    </div>
  );
};
```

**ì¬ì£¼ë¬¸ ì•Œë¦¼ íŒ¨ë„**:

```typescript
// src/components/inventory/ReorderAlerts.tsx

export const ReorderAlerts: React.FC = () => {
  const { data: alerts } = useQuery({
    queryKey: ['reorderAlerts'],
    queryFn: () => inventoryService.getReorderAlerts(),
    refetchInterval: 60 * 1000 // 1ë¶„ë§ˆë‹¤
  });

  const createPurchaseOrder = useMutation({
    mutationFn: (alert: ReorderAlert) =>
      purchaseOrderService.createFromReorder(alert),
    onSuccess: () => {
      toast.success('ë°œì£¼ì„œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤');
      queryClient.invalidateQueries({ queryKey: ['reorderAlerts'] });
    }
  });

  if (!alerts || alerts.length === 0) {
    return (
      <div className="no-alerts">
        âœ… ì¬ì£¼ë¬¸ì´ í•„ìš”í•œ í’ˆëª©ì´ ì—†ìŠµë‹ˆë‹¤
      </div>
    );
  }

  return (
    <div className="reorder-alerts">
      <h3>âš ï¸ ì¬ì£¼ë¬¸ ì•Œë¦¼ ({alerts.length}ê°œ)</h3>

      <div className="alerts-list">
        {alerts.map(alert => (
          <div key={alert.item.id} className={`alert-card ${alert.urgencyLevel}`}>
            <div className="alert-header">
              <span className="item-name">{alert.item.itemName}</span>
              <span className={`urgency-badge ${alert.urgencyLevel}`}>
                {alert.urgencyLevel === 'high' ? 'ê¸´ê¸‰' :
                 alert.urgencyLevel === 'medium' ? 'ë³´í†µ' : 'ë‚®ìŒ'}
              </span>
            </div>

            <div className="alert-body">
              <div className="stock-info">
                <div className="current">
                  í˜„ì¬ ì¬ê³ : <strong>{alert.currentStock}ê°œ</strong>
                </div>
                <div className="reorder-point">
                  ì¬ì£¼ë¬¸ì : {alert.reorderPoint}ê°œ
                </div>
                <div className="deficit">
                  ë¶€ì¡±ëŸ‰: <strong className="text-red-600">
                    {alert.deficit}ê°œ
                  </strong>
                </div>
              </div>

              <div className="recommendation">
                <div className="order-qty">
                  ê¶Œì¥ ë°œì£¼ëŸ‰: <strong>{alert.recommendedOrderQuantity}ê°œ</strong>
                </div>
                <div className="arrival-date">
                  ì˜ˆìƒ ë„ì°©ì¼: {format(new Date(alert.estimatedArrivalDate), 'yyyy-MM-dd')}
                </div>
              </div>
            </div>

            <div className="alert-actions">
              <button
                onClick={() => createPurchaseOrder.mutate(alert)}
                className="btn-create-order"
              >
                ë°œì£¼ì„œ ìƒì„±
              </button>
              <button className="btn-view-details">
                ìƒì„¸ ë³´ê¸°
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
```

### 3.2.5 ìë™ ì¬ê³„ì‚° ìŠ¤ì¼€ì¤„ëŸ¬

```rust
// src-tauri/src/inventory/safety_stock_scheduler.rs

pub async fn start_recalculation_scheduler(
    db: Arc<SqlitePool>,
    interval_hours: u64 // ê¸°ë³¸ 24ì‹œê°„
) {
    let mut interval = tokio::time::interval(Duration::from_secs(interval_hours * 3600));

    loop {
        interval.tick().await;

        info!("Starting safety stock recalculation...");

        match recalculate_all_safety_stocks(&db).await {
            Ok(count) => {
                info!("Recalculated safety stock for {} items", count);
            }
            Err(e) => {
                error!("Safety stock recalculation failed: {}", e);
            }
        }
    }
}

async fn recalculate_all_safety_stocks(
    db: &SqlitePool
) -> Result<usize, Box<dyn Error>> {
    // ëª¨ë“  í’ˆëª© ì¡°íšŒ
    let items = sqlx::query_as!(
        SafetyStockSettings,
        "SELECT * FROM safety_stock_settings"
    )
    .fetch_all(db)
    .await?;

    let mut updated_count = 0;

    for item in items {
        // ìµœê·¼ 30ì¼ ê±°ë˜ ë‚´ì—­ìœ¼ë¡œ ì¼ì¼ ì‚¬ìš©ëŸ‰ í†µê³„ ì¬ê³„ì‚°
        let (daily_avg, daily_std) = calculate_daily_usage_stats(db, &item.item_id).await?;

        // ì•ˆì „ì¬ê³  ì¬ê³„ì‚°
        let new_safety_stock = calculate_safety_stock(
            daily_avg,
            daily_std,
            item.lead_time_days,
            item.service_level
        );

        // ì¬ì£¼ë¬¸ì  ì¬ê³„ì‚°
        let new_reorder_point = calculate_reorder_point(
            daily_avg,
            item.lead_time_days,
            new_safety_stock
        );

        // DB ì—…ë°ì´íŠ¸
        sqlx::query!(
            r#"
            UPDATE safety_stock_settings
            SET
                safety_stock_level = ?,
                reorder_point = ?,
                daily_usage_avg = ?,
                daily_usage_std = ?,
                last_calculated_at = ?
            WHERE id = ?
            "#,
            new_safety_stock,
            new_reorder_point,
            daily_avg,
            daily_std,
            Utc::now().to_rfc3339(),
            item.id
        )
        .execute(db)
        .await?;

        updated_count += 1;
    }

    Ok(updated_count)
}
```

---

### 3.3 MRP ëª¨ë“ˆ (ìì¬ì†Œìš”ê³„íš)

#### 3.3.1 ëª¨ë“ˆ ê°œìš”

**í•µì‹¬ ê¸°ëŠ¥**:
- ì¬ê³  íšŒì „ìœ¨ ë¶„ì„ (Inventory Turnover Analysis)
- ê³ ê°ë³„ ì£¼ë¬¸ íŒ¨í„´ ë¶„ì„ (Customer Order Patterns)
- FIFO ê´€ë¦¬ ë° ìœ„ë°˜ ê°ì§€
- AI ê¸°ë°˜ ìµœì  ë°œì£¼ íƒ€ì´ë° ì¶”ì²œ

**ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜**:
- ì¬ê³  íšŒì „ìœ¨ 15% ê°œì„  ëª©í‘œ
- FIFO ì¤€ìˆ˜ìœ¨ 99% ë‹¬ì„±
- ë°œì£¼ íƒ€ì´ë° ìµœì í™”ë¡œ ì¬ê³  ë¹„ìš© 10% ì ˆê°

#### 3.3.2 ë°ì´í„° ëª¨ë¸

**Rust SeaORM Entity**:
```rust
// src-tauri/src/inventory/models/mrp_analysis.rs

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "mrp_analysis")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: String,
    pub item_id: String,
    pub period_start: DateTimeUtc,
    pub period_end: DateTimeUtc,

    // ì¬ê³  íšŒì „ìœ¨ ë¶„ì„
    pub turnover_rate: f64,          // íšŒì „ìœ¨ (ì—°ê°„)
    pub days_of_inventory: i32,      // ì¬ê³  ì¼ìˆ˜
    pub cogs: f64,                   // ë§¤ì¶œì›ê°€ (Cost of Goods Sold)
    pub avg_inventory_value: f64,    // í‰ê·  ì¬ê³  ê°€ì¹˜

    // ì£¼ë¬¸ íŒ¨í„´ ë¶„ì„
    pub order_frequency: String,     // daily|weekly|monthly
    pub seasonal_pattern: Option<Json>, // ê³„ì ˆì„± íŒ¨í„´ (JSON)
    pub peak_order_days: Option<Json>,  // í”¼í¬ ì£¼ë¬¸ì¼ (ìš”ì¼ë³„)

    // FIFO ì¤€ìˆ˜ìœ¨
    pub fifo_compliance_rate: f64,   // 0.0~1.0
    pub fifo_violations: i32,        // ìœ„ë°˜ ê±´ìˆ˜
    pub oldest_stock_age_days: i32,  // ê°€ì¥ ì˜¤ë˜ëœ ì¬ê³  ì¼ìˆ˜

    // AI ì¶”ì²œ
    pub recommended_order_date: Option<DateTimeUtc>,
    pub recommended_order_quantity: i32,
    pub confidence_score: f64,

    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::inventory_item::Entity",
        from = "Column::ItemId",
        to = "super::inventory_item::Column::Id"
    )]
    InventoryItem,
}

impl Related<super::inventory_item::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::InventoryItem.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

**TypeScript íƒ€ì…**:
```typescript
// src/types/inventory/mrp.ts

export interface MRPAnalysis {
  id: string;
  itemId: string;
  periodStart: string;
  periodEnd: string;

  // ì¬ê³  íšŒì „ìœ¨
  turnoverRate: number;
  daysOfInventory: number;
  cogs: number;
  avgInventoryValue: number;

  // ì£¼ë¬¸ íŒ¨í„´
  orderFrequency: 'daily' | 'weekly' | 'monthly';
  seasonalPattern?: SeasonalPattern;
  peakOrderDays?: number[]; // 0=ì¼ìš”ì¼, 6=í† ìš”ì¼

  // FIFO
  fifoComplianceRate: number;
  fifoViolations: number;
  oldestStockAgeDays: number;

  // AI ì¶”ì²œ
  recommendedOrderDate?: string;
  recommendedOrderQuantity: number;
  confidenceScore: number;

  createdAt: string;
  updatedAt: string;
}

export interface SeasonalPattern {
  type: 'monthly' | 'quarterly';
  peaks: number[]; // ì›”ë³„ ì¸ë±ìŠ¤ (1-12) ë˜ëŠ” ë¶„ê¸° (1-4)
  multipliers: number[]; // ê¸°ì¤€ ëŒ€ë¹„ ë°°ìˆ˜
}

export interface FIFOViolation {
  id: string;
  itemId: string;
  itemName: string;
  violationDate: string;
  expectedLot: string;     // FIFOì— ë”°ë¼ ì‚¬ìš©í•´ì•¼ í•  LOT
  actualLot: string;       // ì‹¤ì œ ì‚¬ìš©í•œ LOT
  quantityUsed: number;
  reason?: string;
}
```

#### 3.3.3 í•µì‹¬ ì•Œê³ ë¦¬ì¦˜

**1. ì¬ê³  íšŒì „ìœ¨ ê³„ì‚°**:
```rust
// src-tauri/src/inventory/services/mrp_service.rs

pub struct TurnoverCalculator;

impl TurnoverCalculator {
    /// ì¬ê³  íšŒì „ìœ¨ ê³„ì‚°
    /// ê³µì‹: Turnover Rate = COGS / Average Inventory Value
    pub fn calculate_turnover_rate(
        cogs: f64,                    // ë§¤ì¶œì›ê°€
        avg_inventory_value: f64       // í‰ê·  ì¬ê³  ê°€ì¹˜
    ) -> f64 {
        if avg_inventory_value <= 0.0 {
            return 0.0;
        }
        cogs / avg_inventory_value
    }

    /// ì¬ê³  ì¼ìˆ˜ ê³„ì‚°
    /// ê³µì‹: Days of Inventory = 365 / Turnover Rate
    pub fn calculate_days_of_inventory(turnover_rate: f64) -> i32 {
        if turnover_rate <= 0.0 {
            return 365;
        }
        (365.0 / turnover_rate).ceil() as i32
    }

    /// COGS (ë§¤ì¶œì›ê°€) ê³„ì‚°
    pub async fn calculate_cogs(
        db: &SqlitePool,
        item_id: &str,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>
    ) -> Result<f64, Box<dyn std::error::Error>> {
        let result = sqlx::query!(
            r#"
            SELECT SUM(quantity * unit_cost) as total_cogs
            FROM inventory_transactions
            WHERE item_id = ?1
              AND transaction_type = 'usage'
              AND created_at BETWEEN ?2 AND ?3
            "#,
            item_id,
            start_date,
            end_date
        )
        .fetch_one(db)
        .await?;

        Ok(result.total_cogs.unwrap_or(0.0))
    }

    /// í‰ê·  ì¬ê³  ê°€ì¹˜ ê³„ì‚°
    pub async fn calculate_avg_inventory_value(
        db: &SqlitePool,
        item_id: &str,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>
    ) -> Result<f64, Box<dyn std::error::Error>> {
        // ì¼ë³„ ì¬ê³  ê°€ì¹˜ë¥¼ ìƒ˜í”Œë§í•˜ì—¬ í‰ê·  ê³„ì‚°
        let days = (end_date - start_date).num_days();
        let sample_interval = if days > 30 { 7 } else { 1 }; // 30ì¼ ì´ìƒì´ë©´ ì£¼ë³„ ìƒ˜í”Œë§

        let mut total_value = 0.0;
        let mut sample_count = 0;

        let mut current_date = start_date;
        while current_date <= end_date {
            let daily_value = self.get_inventory_value_at_date(db, item_id, current_date).await?;
            total_value += daily_value;
            sample_count += 1;

            current_date += Duration::days(sample_interval);
        }

        Ok(if sample_count > 0 {
            total_value / sample_count as f64
        } else {
            0.0
        })
    }
}
```

**2. ì£¼ë¬¸ íŒ¨í„´ ë¶„ì„ (ì‹œê³„ì—´ ë¶„ì„)**:
```rust
use std::collections::HashMap;

pub struct OrderPatternAnalyzer;

impl OrderPatternAnalyzer {
    /// ì£¼ë¬¸ ë¹ˆë„ ë¶„ì„
    pub async fn analyze_order_frequency(
        db: &SqlitePool,
        item_id: &str,
        lookback_days: i32
    ) -> Result<String, Box<dyn std::error::Error>> {
        let end_date = Utc::now();
        let start_date = end_date - Duration::days(lookback_days as i64);

        let orders = sqlx::query!(
            r#"
            SELECT DATE(order_date) as order_day, COUNT(*) as order_count
            FROM customer_orders
            WHERE item_id = ?1
              AND order_date BETWEEN ?2 AND ?3
            GROUP BY DATE(order_date)
            "#,
            item_id,
            start_date,
            end_date
        )
        .fetch_all(db)
        .await?;

        let order_days = orders.len();
        let total_days = lookback_days;

        let frequency_ratio = order_days as f64 / total_days as f64;

        // ë¹ˆë„ ë¶„ë¥˜
        let frequency = if frequency_ratio >= 0.8 {
            "daily"
        } else if frequency_ratio >= 0.3 {
            "weekly"
        } else {
            "monthly"
        };

        Ok(frequency.to_string())
    }

    /// ê³„ì ˆì„± íŒ¨í„´ ë¶„ì„ (ì›”ë³„)
    pub async fn analyze_seasonal_pattern(
        db: &SqlitePool,
        item_id: &str,
        lookback_months: i32
    ) -> Result<SeasonalPattern, Box<dyn std::error::Error>> {
        let orders = sqlx::query!(
            r#"
            SELECT
                strftime('%m', order_date) as month,
                SUM(quantity) as total_quantity
            FROM customer_orders
            WHERE item_id = ?1
              AND order_date >= date('now', '-' || ?2 || ' months')
            GROUP BY strftime('%m', order_date)
            "#,
            item_id,
            lookback_months
        )
        .fetch_all(db)
        .await?;

        let mut monthly_totals: HashMap<i32, f64> = HashMap::new();
        for order in orders {
            let month: i32 = order.month.parse()?;
            monthly_totals.insert(month, order.total_quantity);
        }

        // í‰ê·  ê³„ì‚°
        let avg_quantity = monthly_totals.values().sum::<f64>() / monthly_totals.len() as f64;

        // í”¼í¬ ì›” ì°¾ê¸° (í‰ê·  ëŒ€ë¹„ 1.5ë°° ì´ìƒ)
        let mut peaks = Vec::new();
        let mut multipliers = Vec::new();

        for month in 1..=12 {
            if let Some(&quantity) = monthly_totals.get(&month) {
                let multiplier = quantity / avg_quantity;
                if multiplier >= 1.5 {
                    peaks.push(month);
                    multipliers.push(multiplier);
                }
            }
        }

        Ok(SeasonalPattern {
            pattern_type: "monthly".to_string(),
            peaks,
            multipliers,
        })
    }

    /// ìš”ì¼ë³„ í”¼í¬ ë¶„ì„
    pub async fn analyze_peak_order_days(
        db: &SqlitePool,
        item_id: &str
    ) -> Result<Vec<i32>, Box<dyn std::error::Error>> {
        let orders = sqlx::query!(
            r#"
            SELECT
                CAST(strftime('%w', order_date) AS INTEGER) as day_of_week,
                SUM(quantity) as total_quantity
            FROM customer_orders
            WHERE item_id = ?1
              AND order_date >= date('now', '-90 days')
            GROUP BY strftime('%w', order_date)
            "#,
            item_id
        )
        .fetch_all(db)
        .await?;

        let mut daily_totals: HashMap<i32, f64> = HashMap::new();
        for order in orders {
            daily_totals.insert(order.day_of_week, order.total_quantity);
        }

        let avg_quantity = daily_totals.values().sum::<f64>() / 7.0;

        // í‰ê·  ëŒ€ë¹„ 1.3ë°° ì´ìƒì¸ ìš”ì¼
        let peak_days: Vec<i32> = daily_totals.iter()
            .filter(|(_, &qty)| qty >= avg_quantity * 1.3)
            .map(|(&day, _)| day)
            .collect();

        Ok(peak_days)
    }
}
```

**3. FIFO ì¶”ì  ë° ìœ„ë°˜ ê°ì§€**:
```rust
pub struct FIFOTracker;

impl FIFOTracker {
    /// FIFO ìœ„ë°˜ ê°ì§€
    pub async fn detect_fifo_violations(
        db: &SqlitePool,
        item_id: &str,
        period_days: i32
    ) -> Result<Vec<FIFOViolation>, Box<dyn std::error::Error>> {
        let mut violations = Vec::new();

        // ì‚¬ìš© íŠ¸ëœì­ì…˜ ê°€ì ¸ì˜¤ê¸°
        let usage_transactions = sqlx::query!(
            r#"
            SELECT id, lot_number, quantity, created_at
            FROM inventory_transactions
            WHERE item_id = ?1
              AND transaction_type = 'usage'
              AND created_at >= date('now', '-' || ?2 || ' days')
            ORDER BY created_at
            "#,
            item_id,
            period_days
        )
        .fetch_all(db)
        .await?;

        for transaction in usage_transactions {
            // í•´ë‹¹ ì‹œì ì— ê°€ì¥ ì˜¤ë˜ëœ LOT ì°¾ê¸°
            let oldest_lot = sqlx::query!(
                r#"
                SELECT lot_number, MIN(received_date) as oldest_date
                FROM inventory_lots
                WHERE item_id = ?1
                  AND quantity_remaining > 0
                  AND received_date <= ?2
                GROUP BY lot_number
                ORDER BY oldest_date
                LIMIT 1
                "#,
                item_id,
                transaction.created_at
            )
            .fetch_optional(db)
            .await?;

            if let Some(oldest) = oldest_lot {
                if transaction.lot_number != oldest.lot_number {
                    // FIFO ìœ„ë°˜ ë°œê²¬!
                    violations.push(FIFOViolation {
                        id: Uuid::new_v4().to_string(),
                        item_id: item_id.to_string(),
                        violation_date: transaction.created_at.to_rfc3339(),
                        expected_lot: oldest.lot_number,
                        actual_lot: transaction.lot_number,
                        quantity_used: transaction.quantity,
                        reason: None,
                    });
                }
            }
        }

        Ok(violations)
    }

    /// FIFO ì¤€ìˆ˜ìœ¨ ê³„ì‚°
    pub async fn calculate_fifo_compliance_rate(
        db: &SqlitePool,
        item_id: &str,
        period_days: i32
    ) -> Result<f64, Box<dyn std::error::Error>> {
        let total_transactions = sqlx::query!(
            r#"
            SELECT COUNT(*) as count
            FROM inventory_transactions
            WHERE item_id = ?1
              AND transaction_type = 'usage'
              AND created_at >= date('now', '-' || ?2 || ' days')
            "#,
            item_id,
            period_days
        )
        .fetch_one(db)
        .await?
        .count;

        let violations = self.detect_fifo_violations(db, item_id, period_days).await?;
        let violation_count = violations.len() as i32;

        if total_transactions == 0 {
            return Ok(1.0); // íŠ¸ëœì­ì…˜ ì—†ìœ¼ë©´ 100% ì¤€ìˆ˜
        }

        let compliance_rate = 1.0 - (violation_count as f64 / total_transactions as f64);
        Ok(compliance_rate.max(0.0))
    }

    /// ê°€ì¥ ì˜¤ë˜ëœ ì¬ê³  ì¼ìˆ˜ ê³„ì‚°
    pub async fn get_oldest_stock_age(
        db: &SqlitePool,
        item_id: &str
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let oldest = sqlx::query!(
            r#"
            SELECT MIN(received_date) as oldest_date
            FROM inventory_lots
            WHERE item_id = ?1 AND quantity_remaining > 0
            "#,
            item_id
        )
        .fetch_one(db)
        .await?;

        if let Some(oldest_date) = oldest.oldest_date {
            let age_days = (Utc::now() - oldest_date).num_days();
            Ok(age_days as i32)
        } else {
            Ok(0)
        }
    }
}
```

**4. AI ê¸°ë°˜ ìµœì  ë°œì£¼ íƒ€ì´ë° ì¶”ì²œ**:
```rust
use serde_json::json;

pub struct OptimalOrderTimingAI {
    claude_api: ClaudeAPI,
}

impl OptimalOrderTimingAI {
    pub async fn recommend_order_timing(
        &self,
        mrp_data: &MRPAnalysis,
        historical_orders: &[CustomerOrder]
    ) -> Result<OrderRecommendation, Box<dyn std::error::Error>> {
        let prompt = self.build_prompt(mrp_data, historical_orders);

        let response = self.claude_api.send_message(&prompt).await?;
        let recommendation: OrderRecommendation = serde_json::from_str(&response)?;

        Ok(recommendation)
    }

    fn build_prompt(&self, mrp_data: &MRPAnalysis, orders: &[CustomerOrder]) -> String {
        format!(
            r#"ì œì¡°ì—… MRP ì „ë¬¸ê°€ë¡œì„œ ìµœì  ë°œì£¼ íƒ€ì´ë°ì„ ì¶”ì²œí•´ì£¼ì„¸ìš”.

## í˜„ì¬ ì¬ê³  ë¶„ì„ ë°ì´í„°

**ì¬ê³  íšŒì „ìœ¨**:
- íšŒì „ìœ¨: {:.2} (ì—°ê°„)
- ì¬ê³  ì¼ìˆ˜: {} ì¼
- COGS: {:,.0} ì›
- í‰ê·  ì¬ê³  ê°€ì¹˜: {:,.0} ì›

**ì£¼ë¬¸ íŒ¨í„´**:
- ì£¼ë¬¸ ë¹ˆë„: {}
- ê³„ì ˆì„± íŒ¨í„´: {:?}
- í”¼í¬ ì£¼ë¬¸ ìš”ì¼: {:?}

**FIFO ì¤€ìˆ˜**:
- ì¤€ìˆ˜ìœ¨: {:.1}%
- ìœ„ë°˜ ê±´ìˆ˜: {} ê±´
- ê°€ì¥ ì˜¤ë˜ëœ ì¬ê³ : {} ì¼

**ìµœê·¼ 3ê°œì›” ì£¼ë¬¸ ì´ë ¥**:
{}

## ìš”ì²­ì‚¬í•­

ë‹¤ìŒ ì •ë³´ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ì œê³µí•´ì£¼ì„¸ìš”:

```json
{{
  "recommended_order_date": "YYYY-MM-DD",
  "recommended_quantity": ìˆ«ì,
  "confidence_score": 0.0~1.0,
  "reasoning": "ì¶”ì²œ ê·¼ê±° ì„¤ëª…",
  "risk_factors": ["ìœ„í—˜ ìš”ì†Œ1", "ìœ„í—˜ ìš”ì†Œ2"],
  "alternative_dates": [
    {{"date": "YYYY-MM-DD", "quantity": ìˆ«ì, "reason": "ì´ìœ "}}
  ]
}}
```

**ê³ ë ¤ì‚¬í•­**:
1. ì¬ê³  íšŒì „ìœ¨ì„ ìµœì í™”í•˜ì—¬ ì¬ê³  ë¹„ìš© ìµœì†Œí™”
2. FIFO ì¤€ìˆ˜ë¥¼ ìœ„í•œ ì ì ˆí•œ ë°œì£¼ëŸ‰ ê³„ì‚°
3. ê³„ì ˆì„± ë° í”¼í¬ ì‹œì¦Œ ëŒ€ë¹„
4. ë¦¬ë“œíƒ€ì„ ë° ì•ˆì „ì¬ê³  ê³ ë ¤
"#,
            mrp_data.turnover_rate,
            mrp_data.days_of_inventory,
            mrp_data.cogs,
            mrp_data.avg_inventory_value,
            mrp_data.order_frequency,
            mrp_data.seasonal_pattern,
            mrp_data.peak_order_days,
            mrp_data.fifo_compliance_rate * 100.0,
            mrp_data.fifo_violations,
            mrp_data.oldest_stock_age_days,
            self.format_order_history(orders)
        )
    }
}

#[derive(Deserialize, Serialize)]
pub struct OrderRecommendation {
    pub recommended_order_date: String,
    pub recommended_quantity: i32,
    pub confidence_score: f64,
    pub reasoning: String,
    pub risk_factors: Vec<String>,
    pub alternative_dates: Vec<AlternativeOrder>,
}

#[derive(Deserialize, Serialize)]
pub struct AlternativeOrder {
    pub date: String,
    pub quantity: i32,
    pub reason: String,
}
```

#### 3.3.4 UI ì»´í¬ë„ŒíŠ¸

**1. MRP ë¶„ì„ ì°¨íŠ¸**:
```typescript
// src/components/Inventory/MRP/MRPAnalysisChart.tsx

import React from 'react';
import { Line, Bar } from 'react-chartjs-2';
import { MRPAnalysis } from '@/types/inventory/mrp';

interface Props {
  data: MRPAnalysis[];
  itemName: string;
}

export const MRPAnalysisChart: React.FC<Props> = ({ data, itemName }) => {
  const turnoverData = {
    labels: data.map(d => new Date(d.periodEnd).toLocaleDateString('ko-KR')),
    datasets: [
      {
        label: 'ì¬ê³  íšŒì „ìœ¨',
        data: data.map(d => d.turnoverRate),
        borderColor: 'rgb(75, 192, 192)',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
        yAxisID: 'y-turnover',
      },
      {
        label: 'ì¬ê³  ì¼ìˆ˜',
        data: data.map(d => d.daysOfInventory),
        borderColor: 'rgb(255, 99, 132)',
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        yAxisID: 'y-days',
      },
    ],
  };

  const options = {
    responsive: true,
    interaction: {
      mode: 'index' as const,
      intersect: false,
    },
    plugins: {
      title: {
        display: true,
        text: `${itemName} - ì¬ê³  íšŒì „ìœ¨ ì¶”ì´`,
      },
      tooltip: {
        callbacks: {
          label: function(context: any) {
            let label = context.dataset.label || '';
            if (label) {
              label += ': ';
            }
            if (context.parsed.y !== null) {
              label += context.dataset.yAxisID === 'y-turnover'
                ? context.parsed.y.toFixed(2) + 'íšŒ'
                : context.parsed.y + 'ì¼';
            }
            return label;
          }
        }
      }
    },
    scales: {
      'y-turnover': {
        type: 'linear' as const,
        display: true,
        position: 'left' as const,
        title: {
          display: true,
          text: 'íšŒì „ìœ¨ (íšŒ)',
        },
      },
      'y-days': {
        type: 'linear' as const,
        display: true,
        position: 'right' as const,
        title: {
          display: true,
          text: 'ì¬ê³  ì¼ìˆ˜ (ì¼)',
        },
        grid: {
          drawOnChartArea: false,
        },
      },
    },
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <Line data={turnoverData} options={options} />

      {/* ê³„ì ˆì„± íŒ¨í„´ ì°¨íŠ¸ */}
      {data[data.length - 1]?.seasonalPattern && (
        <div className="mt-6">
          <h4 className="text-lg font-semibold mb-3">ê³„ì ˆì„± íŒ¨í„´</h4>
          <Bar
            data={{
              labels: data[data.length - 1].seasonalPattern.peaks.map(m => `${m}ì›”`),
              datasets: [{
                label: 'í‰ê·  ëŒ€ë¹„ ë°°ìˆ˜',
                data: data[data.length - 1].seasonalPattern.multipliers,
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
              }],
            }}
            options={{
              responsive: true,
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'í‰ê·  ëŒ€ë¹„ ë°°ìˆ˜',
                  },
                },
              },
            }}
          />
        </div>
      )}
    </div>
  );
};
```

**2. FIFO ì¤€ìˆ˜ íŠ¸ë˜ì»¤**:
```typescript
// src/components/Inventory/MRP/FIFOComplianceTracker.tsx

import React, { useState, useEffect } from 'react';
import { FIFOViolation, MRPAnalysis } from '@/types/inventory/mrp';
import { invokeTauriCommand } from '@/utils/tauri';

interface Props {
  itemId: string;
  itemName: string;
}

export const FIFOComplianceTracker: React.FC<Props> = ({ itemId, itemName }) => {
  const [mrpData, setMrpData] = useState<MRPAnalysis | null>(null);
  const [violations, setViolations] = useState<FIFOViolation[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadFIFOData();
  }, [itemId]);

  const loadFIFOData = async () => {
    try {
      const [data, viols] = await Promise.all([
        invokeTauriCommand<MRPAnalysis>('get_latest_mrp_analysis', { itemId }),
        invokeTauriCommand<FIFOViolation[]>('get_fifo_violations', { itemId, periodDays: 30 }),
      ]);
      setMrpData(data);
      setViolations(viols);
    } catch (error) {
      console.error('FIFO ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div className="animate-pulse bg-gray-200 h-64 rounded-lg"></div>;
  }

  if (!mrpData) {
    return <div className="text-gray-500">ë°ì´í„° ì—†ìŒ</div>;
  }

  const complianceRate = mrpData.fifoComplianceRate * 100;
  const isGood = complianceRate >= 95;

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <h3 className="text-xl font-bold mb-4">{itemName} - FIFO ì¤€ìˆ˜ í˜„í™©</h3>

      {/* ì¤€ìˆ˜ìœ¨ ê²Œì´ì§€ */}
      <div className="mb-6">
        <div className="flex items-center justify-between mb-2">
          <span className="text-sm font-medium">FIFO ì¤€ìˆ˜ìœ¨</span>
          <span className={`text-2xl font-bold ${isGood ? 'text-green-600' : 'text-red-600'}`}>
            {complianceRate.toFixed(1)}%
          </span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-4">
          <div
            className={`h-4 rounded-full ${isGood ? 'bg-green-500' : 'bg-red-500'}`}
            style={{ width: `${complianceRate}%` }}
          ></div>
        </div>
      </div>

      {/* ì£¼ìš” ì§€í‘œ */}
      <div className="grid grid-cols-3 gap-4 mb-6">
        <div className="text-center p-3 bg-gray-50 rounded">
          <div className="text-sm text-gray-600">ìœ„ë°˜ ê±´ìˆ˜ (30ì¼)</div>
          <div className="text-xl font-bold text-red-600">{violations.length}ê±´</div>
        </div>
        <div className="text-center p-3 bg-gray-50 rounded">
          <div className="text-sm text-gray-600">ê°€ì¥ ì˜¤ë˜ëœ ì¬ê³ </div>
          <div className="text-xl font-bold text-orange-600">{mrpData.oldestStockAgeDays}ì¼</div>
        </div>
        <div className="text-center p-3 bg-gray-50 rounded">
          <div className="text-sm text-gray-600">ì¬ê³  ì¼ìˆ˜</div>
          <div className="text-xl font-bold text-blue-600">{mrpData.daysOfInventory}ì¼</div>
        </div>
      </div>

      {/* ìœ„ë°˜ ë‚´ì—­ */}
      {violations.length > 0 && (
        <div>
          <h4 className="font-semibold mb-2 text-red-600">ìµœê·¼ FIFO ìœ„ë°˜ ë‚´ì—­</h4>
          <div className="space-y-2 max-h-64 overflow-y-auto">
            {violations.map((violation) => (
              <div key={violation.id} className="border border-red-200 bg-red-50 p-3 rounded">
                <div className="flex justify-between items-start mb-1">
                  <span className="text-sm font-medium">
                    {new Date(violation.violationDate).toLocaleDateString('ko-KR')}
                  </span>
                  <span className="text-xs text-red-600 font-semibold">FIFO ìœ„ë°˜</span>
                </div>
                <div className="text-sm text-gray-700">
                  <div>ì˜ˆìƒ LOT: <span className="font-mono">{violation.expectedLot}</span></div>
                  <div>ì‹¤ì œ ì‚¬ìš© LOT: <span className="font-mono text-red-600">{violation.actualLot}</span></div>
                  <div>ì‚¬ìš©ëŸ‰: {violation.quantityUsed}ê°œ</div>
                  {violation.reason && (
                    <div className="mt-1 text-xs text-gray-600">ì‚¬ìœ : {violation.reason}</div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* ê¶Œì¥ ì¡°ì¹˜ */}
      {!isGood && (
        <div className="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded">
          <h4 className="font-semibold text-yellow-800 mb-2">âš ï¸ ê¶Œì¥ ì¡°ì¹˜</h4>
          <ul className="text-sm text-yellow-700 space-y-1">
            <li>â€¢ ê°€ì¥ ì˜¤ë˜ëœ LOT({mrpData.oldestStockAgeDays}ì¼)ë¥¼ ìš°ì„  ì‚¬ìš©í•˜ì„¸ìš”</li>
            <li>â€¢ ì¬ê³  ìœ„ì¹˜ë¥¼ FIFO ìˆœì„œëŒ€ë¡œ ì¬ì •ë¦¬í•˜ì„¸ìš”</li>
            <li>â€¢ ë°œì£¼ ì‹œ ê³¼ë‹¤ ì£¼ë¬¸ì„ í”¼í•˜ì„¸ìš” (í˜„ì¬ ì¬ê³  ì¼ìˆ˜: {mrpData.daysOfInventory}ì¼)</li>
          </ul>
        </div>
      )}
    </div>
  );
};
```

#### 3.3.5 ì„±ëŠ¥ ìµœì í™”

**1. ì¬ê³  íšŒì „ìœ¨ ê³„ì‚° ìµœì í™” (Materialized View í™œìš©)**:
```sql
-- ì›”ë³„ ì¬ê³  íšŒì „ìœ¨ ì‚¬ì „ ê³„ì‚° (Materialized View ëŒ€ì‹  í…Œì´ë¸” í™œìš©)
CREATE TABLE IF NOT EXISTS monthly_turnover_stats (
    id TEXT PRIMARY KEY,
    item_id TEXT NOT NULL,
    year_month TEXT NOT NULL, -- 'YYYY-MM' í˜•ì‹
    turnover_rate REAL NOT NULL,
    days_of_inventory INTEGER NOT NULL,
    cogs REAL NOT NULL,
    avg_inventory_value REAL NOT NULL,
    calculated_at TEXT NOT NULL,
    UNIQUE(item_id, year_month)
);

CREATE INDEX idx_monthly_turnover_item ON monthly_turnover_stats(item_id);
CREATE INDEX idx_monthly_turnover_month ON monthly_turnover_stats(year_month);
```

**2. ì¼ì¼ ë°°ì¹˜ ê³„ì‚° ìŠ¤ì¼€ì¤„ëŸ¬**:
```rust
// src-tauri/src/inventory/schedulers/mrp_scheduler.rs

use tokio::time::{interval, Duration};

pub struct MRPScheduler {
    db: SqlitePool,
    mrp_service: MRPAnalysisService,
}

impl MRPScheduler {
    pub async fn start(&self) {
        let mut interval = interval(Duration::from_secs(24 * 60 * 60)); // 24ì‹œê°„

        loop {
            interval.tick().await;

            if let Err(e) = self.recalculate_all_mrp_stats().await {
                eprintln!("MRP í†µê³„ ì¬ê³„ì‚° ì‹¤íŒ¨: {}", e);
            }
        }
    }

    async fn recalculate_all_mrp_stats(&self) -> Result<(), Box<dyn std::error::Error>> {
        println!("[MRP Scheduler] ì›”ë³„ ì¬ê³  íšŒì „ìœ¨ í†µê³„ ì¬ê³„ì‚° ì‹œì‘...");

        let items = sqlx::query!("SELECT DISTINCT id FROM inventory_items WHERE is_active = 1")
            .fetch_all(&self.db)
            .await?;

        let last_month_start = Utc::now()
            .checked_sub_months(Months::new(1))
            .unwrap()
            .date_naive()
            .and_hms_opt(0, 0, 0)
            .unwrap()
            .and_local_timezone(Utc)
            .unwrap();
        let last_month_end = Utc::now()
            .date_naive()
            .and_hms_opt(0, 0, 0)
            .unwrap()
            .and_local_timezone(Utc)
            .unwrap();

        for item in items {
            let turnover_rate = self.mrp_service.calculate_turnover_rate(
                &item.id,
                last_month_start,
                last_month_end
            ).await?;

            // monthly_turnover_stats í…Œì´ë¸”ì— ì €ì¥
            sqlx::query!(
                r#"
                INSERT INTO monthly_turnover_stats (id, item_id, year_month, turnover_rate, days_of_inventory, cogs, avg_inventory_value, calculated_at)
                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
                ON CONFLICT(item_id, year_month) DO UPDATE SET
                    turnover_rate = excluded.turnover_rate,
                    days_of_inventory = excluded.days_of_inventory,
                    cogs = excluded.cogs,
                    avg_inventory_value = excluded.avg_inventory_value,
                    calculated_at = excluded.calculated_at
                "#,
                Uuid::new_v4().to_string(),
                item.id,
                last_month_start.format("%Y-%m").to_string(),
                turnover_rate.turnover_rate,
                turnover_rate.days_of_inventory,
                turnover_rate.cogs,
                turnover_rate.avg_inventory_value,
                Utc::now().to_rfc3339()
            )
            .execute(&self.db)
            .await?;
        }

        println!("[MRP Scheduler] {} ê°œ í’ˆëª© í†µê³„ ì¬ê³„ì‚° ì™„ë£Œ", items.len());
        Ok(())
    }
}
```

---

### 3.4 ìë™ë°œì£¼ì„œ ëª¨ë“ˆ

#### 3.4.1 ëª¨ë“ˆ ê°œìš”

**í•µì‹¬ ê¸°ëŠ¥**:
- ê³ ê°ë³„ ì»¤ìŠ¤í…€ ë°œì£¼ì„œ í¬ë§· ìƒì„±
- ì—‘ì…€ í…œí”Œë¦¿ ê¸°ë°˜ ìë™ ìƒì„±
- PDF ë³€í™˜ ë° ì´ë©”ì¼ ë°œì†¡
- ë°œì£¼ ì´ë ¥ ì¶”ì 

**ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜**:
- ë°œì£¼ì„œ ì‘ì„± ì‹œê°„ 80% ì ˆê° (20ë¶„ â†’ 4ë¶„)
- ê³ ê°ë³„ ë§ì¶¤ í¬ë§· ìë™ ì ìš©
- ì´ë©”ì¼ ìë™ ë°œì†¡ìœ¼ë¡œ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ íš¨ìœ¨í™”

#### 3.4.2 ë°ì´í„° ëª¨ë¸

**Rust SeaORM Entity**:
```rust
// src-tauri/src/inventory/models/purchase_order.rs

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "purchase_orders")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: String,
    pub order_number: String,           // PO-2025-001
    pub customer_id: String,
    pub customer_name: String,
    pub template_id: String,            // ì‚¬ìš©í•œ í…œí”Œë¦¿ ID
    pub status: String,                 // draft|sent|confirmed|cancelled

    // ë°œì£¼ í’ˆëª©
    pub items: Json,                    // Vec<PurchaseOrderItem>

    // ê¸ˆì•¡ ì •ë³´
    pub subtotal: f64,
    pub tax_amount: f64,
    pub total_amount: f64,

    // ë°°ì†¡ ì •ë³´
    pub delivery_address: String,
    pub delivery_date: DateTimeUtc,
    pub delivery_notes: Option<String>,

    // íŒŒì¼ ì •ë³´
    pub excel_file_path: Option<String>,
    pub pdf_file_path: Option<String>,

    // ë°œì†¡ ì •ë³´
    pub sent_at: Option<DateTimeUtc>,
    pub sent_to_email: Option<String>,
    pub confirmed_at: Option<DateTimeUtc>,

    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
    pub created_by: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PurchaseOrderItem {
    pub item_id: String,
    pub item_code: String,
    pub item_name: String,
    pub specification: Option<String>,
    pub quantity: i32,
    pub unit: String,
    pub unit_price: f64,
    pub amount: f64,
    pub notes: Option<String>,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "purchase_order_templates")]
pub struct POTemplateModel {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: String,
    pub template_name: String,
    pub customer_id: Option<String>,    // nullì´ë©´ ê¸°ë³¸ í…œí”Œë¦¿
    pub excel_template_path: String,    // ì—‘ì…€ í…œí”Œë¦¿ íŒŒì¼ ê²½ë¡œ

    // í•„ë“œ ë§¤í•‘ ì„¤ì • (JSON)
    pub field_mapping: Json,            // {"item_code": "A1", "item_name": "B1", ...}
    pub header_row: i32,                // í—¤ë” ì‹œì‘ í–‰
    pub data_start_row: i32,            // ë°ì´í„° ì‹œì‘ í–‰

    // ìŠ¤íƒ€ì¼ ì„¤ì •
    pub company_logo_cell: Option<String>, // "A1"
    pub highlight_color: Option<String>,   // "#FFD700"

    pub is_active: bool,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}
```

**TypeScript íƒ€ì…**:
```typescript
// src/types/inventory/purchase-order.ts

export interface PurchaseOrder {
  id: string;
  orderNumber: string;
  customerId: string;
  customerName: string;
  templateId: string;
  status: 'draft' | 'sent' | 'confirmed' | 'cancelled';

  items: PurchaseOrderItem[];

  subtotal: number;
  taxAmount: number;
  totalAmount: number;

  deliveryAddress: string;
  deliveryDate: string;
  deliveryNotes?: string;

  excelFilePath?: string;
  pdfFilePath?: string;

  sentAt?: string;
  sentToEmail?: string;
  confirmedAt?: string;

  createdAt: string;
  updatedAt: string;
  createdBy: string;
}

export interface PurchaseOrderItem {
  itemId: string;
  itemCode: string;
  itemName: string;
  specification?: string;
  quantity: number;
  unit: string;
  unitPrice: number;
  amount: number;
  notes?: string;
}

export interface POTemplate {
  id: string;
  templateName: string;
  customerId?: string;
  excelTemplatePath: string;
  fieldMapping: Record<string, string>;
  headerRow: number;
  dataStartRow: number;
  companyLogoCell?: string;
  highlightColor?: string;
  isActive: boolean;
}
```

#### 3.4.3 í•µì‹¬ ì•Œê³ ë¦¬ì¦˜

**1. ì—‘ì…€ ë°œì£¼ì„œ ìë™ ìƒì„±**:
```rust
// src-tauri/src/inventory/services/purchase_order_generator.rs

use rust_xlsxwriter::{Workbook, Worksheet, Format, Color};
use std::path::Path;

pub struct PurchaseOrderGenerator {
    db: SqlitePool,
}

impl PurchaseOrderGenerator {
    pub async fn generate_excel(
        &self,
        order: &PurchaseOrder,
        template: &POTemplate
    ) -> Result<String, Box<dyn std::error::Error>> {
        // í…œí”Œë¦¿ ë³µì‚¬
        let template_path = Path::new(&template.excel_template_path);
        let output_filename = format!("ë°œì£¼ì„œ_{}_{}.xlsx", order.customer_name, order.order_number);
        let output_path = Path::new("output/purchase_orders").join(&output_filename);

        std::fs::create_dir_all("output/purchase_orders")?;

        // í…œí”Œë¦¿ì—ì„œ Workbook ë¡œë“œ (rust_xlsxwriterëŠ” í…œí”Œë¦¿ ìˆ˜ì • ë¯¸ì§€ì›, ìƒˆë¡œ ìƒì„±)
        let mut workbook = Workbook::new();
        let worksheet = workbook.add_worksheet();

        // í—¤ë” ì‘ì„±
        self.write_header(worksheet, order, template)?;

        // í’ˆëª© ë°ì´í„° ì‘ì„±
        self.write_items(worksheet, &order.items, template)?;

        // í•©ê³„ ì‘ì„±
        self.write_totals(worksheet, order, template)?;

        workbook.save(&output_path)?;

        Ok(output_path.to_string_lossy().to_string())
    }

    fn write_header(
        &self,
        worksheet: &mut Worksheet,
        order: &PurchaseOrder,
        template: &POTemplate
    ) -> Result<(), Box<dyn std::error::Error>> {
        let header_format = Format::new()
            .set_bold()
            .set_font_size(14);

        // ë°œì£¼ì„œ ì œëª©
        worksheet.write_string_with_format(0, 0, "ë°œì£¼ì„œ", &header_format)?;

        // ë°œì£¼ë²ˆí˜¸, ë°œì£¼ì¼ì
        worksheet.write_string(2, 0, "ë°œì£¼ë²ˆí˜¸:")?;
        worksheet.write_string(2, 1, &order.order_number)?;
        worksheet.write_string(3, 0, "ë°œì£¼ì¼ì:")?;
        worksheet.write_string(3, 1, &order.created_at.format("%Y-%m-%d").to_string())?;

        // ê³ ê° ì •ë³´
        worksheet.write_string(2, 4, "ê³ ê°ëª…:")?;
        worksheet.write_string(2, 5, &order.customer_name)?;
        worksheet.write_string(3, 4, "ë°°ì†¡ì§€:")?;
        worksheet.write_string(3, 5, &order.delivery_address)?;
        worksheet.write_string(4, 4, "í¬ë§ë°°ì†¡ì¼:")?;
        worksheet.write_string(4, 5, &order.delivery_date.format("%Y-%m-%d").to_string())?;

        Ok(())
    }

    fn write_items(
        &self,
        worksheet: &mut Worksheet,
        items: &[PurchaseOrderItem],
        template: &POTemplate
    ) -> Result<(), Box<dyn std::error::Error>> {
        let header_row = template.header_row as u32;
        let data_start_row = template.data_start_row as u32;

        // í…Œì´ë¸” í—¤ë”
        let header_format = Format::new()
            .set_bold()
            .set_border(rust_xlsxwriter::FormatBorder::Thin)
            .set_background_color(Color::RGB(0xD3D3D3));

        let headers = ["ë²ˆí˜¸", "í’ˆëª©ì½”ë“œ", "í’ˆëª…", "ê·œê²©", "ìˆ˜ëŸ‰", "ë‹¨ìœ„", "ë‹¨ê°€", "ê¸ˆì•¡", "ë¹„ê³ "];
        for (col, header) in headers.iter().enumerate() {
            worksheet.write_string_with_format(header_row, col as u16, header, &header_format)?;
        }

        // í’ˆëª© ë°ì´í„°
        let data_format = Format::new()
            .set_border(rust_xlsxwriter::FormatBorder::Thin);

        let number_format = Format::new()
            .set_border(rust_xlsxwriter::FormatBorder::Thin)
            .set_num_format("#,##0");

        for (idx, item) in items.iter().enumerate() {
            let row = data_start_row + idx as u32;

            worksheet.write_number_with_format(row, 0, (idx + 1) as f64, &data_format)?;
            worksheet.write_string_with_format(row, 1, &item.item_code, &data_format)?;
            worksheet.write_string_with_format(row, 2, &item.item_name, &data_format)?;
            worksheet.write_string_with_format(row, 3, item.specification.as_deref().unwrap_or(""), &data_format)?;
            worksheet.write_number_with_format(row, 4, item.quantity as f64, &number_format)?;
            worksheet.write_string_with_format(row, 5, &item.unit, &data_format)?;
            worksheet.write_number_with_format(row, 6, item.unit_price, &number_format)?;
            worksheet.write_number_with_format(row, 7, item.amount, &number_format)?;
            worksheet.write_string_with_format(row, 8, item.notes.as_deref().unwrap_or(""), &data_format)?;
        }

        Ok(())
    }

    fn write_totals(
        &self,
        worksheet: &mut Worksheet,
        order: &PurchaseOrder,
        template: &POTemplate
    ) -> Result<(), Box<dyn std::error::Error>> {
        let total_row = (template.data_start_row + order.items.len() as i32 + 2) as u32;

        let total_format = Format::new()
            .set_bold()
            .set_border(rust_xlsxwriter::FormatBorder::Thin)
            .set_background_color(Color::RGB(0xFFFFCC));

        let number_format = Format::new()
            .set_bold()
            .set_border(rust_xlsxwriter::FormatBorder::Thin)
            .set_background_color(Color::RGB(0xFFFFCC))
            .set_num_format("#,##0");

        worksheet.write_string_with_format(total_row, 5, "ì†Œê³„:", &total_format)?;
        worksheet.write_number_with_format(total_row, 7, order.subtotal, &number_format)?;

        worksheet.write_string_with_format(total_row + 1, 5, "ë¶€ê°€ì„¸(10%):", &total_format)?;
        worksheet.write_number_with_format(total_row + 1, 7, order.tax_amount, &number_format)?;

        worksheet.write_string_with_format(total_row + 2, 5, "í•©ê³„:", &total_format)?;
        worksheet.write_number_with_format(total_row + 2, 7, order.total_amount, &number_format)?;

        Ok(())
    }
}
```

**2. PDF ë³€í™˜**:
```rust
// PDF ë³€í™˜ì€ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš© (ì˜ˆ: LibreOffice CLI ë˜ëŠ” wkhtmltopdf)

use std::process::Command;

pub struct PDFConverter;

impl PDFConverter {
    pub fn convert_excel_to_pdf(
        excel_path: &str
    ) -> Result<String, Box<dyn std::error::Error>> {
        let pdf_path = excel_path.replace(".xlsx", ".pdf");

        // LibreOfficeë¥¼ ì‚¬ìš©í•œ PDF ë³€í™˜ (ì‹œìŠ¤í…œì— ì„¤ì¹˜ í•„ìš”)
        let output = Command::new("libreoffice")
            .args(&[
                "--headless",
                "--convert-to", "pdf",
                "--outdir", "output/purchase_orders",
                excel_path
            ])
            .output()?;

        if !output.status.success() {
            return Err(format!("PDF ë³€í™˜ ì‹¤íŒ¨: {}", String::from_utf8_lossy(&output.stderr)).into());
        }

        Ok(pdf_path)
    }
}
```

**3. ì´ë©”ì¼ ë°œì†¡**:
```rust
// src-tauri/src/inventory/services/email_sender.rs

use lettre::{Message, SmtpTransport, Transport};
use lettre::message::{header, MultiPart, SinglePart, Attachment};
use std::fs;

pub struct EmailSender {
    smtp_server: String,
    smtp_username: String,
    smtp_password: String,
}

impl EmailSender {
    pub async fn send_purchase_order(
        &self,
        order: &PurchaseOrder,
        recipient_email: &str,
        pdf_path: &str
    ) -> Result<(), Box<dyn std::error::Error>> {
        let pdf_content = fs::read(pdf_path)?;
        let pdf_filename = Path::new(pdf_path)
            .file_name()
            .unwrap()
            .to_string_lossy()
            .to_string();

        let email = Message::builder()
            .from(self.smtp_username.parse()?)
            .to(recipient_email.parse()?)
            .subject(format!("ë°œì£¼ì„œ ì „ì†¡ - {}", order.order_number))
            .multipart(
                MultiPart::mixed()
                    .singlepart(
                        SinglePart::builder()
                            .header(header::ContentType::TEXT_PLAIN)
                            .body(format!(
                                "ì•ˆë…•í•˜ì„¸ìš”,\n\n{}ì— ëŒ€í•œ ë°œì£¼ì„œë¥¼ ì²¨ë¶€í•©ë‹ˆë‹¤.\n\në°œì£¼ë²ˆí˜¸: {}\në°°ì†¡ í¬ë§ì¼: {}\n\nê°ì‚¬í•©ë‹ˆë‹¤.",
                                order.customer_name,
                                order.order_number,
                                order.delivery_date.format("%Y-%m-%d")
                            ))
                    )
                    .singlepart(
                        Attachment::new(pdf_filename)
                            .body(pdf_content, "application/pdf".parse()?)
                    )
            )?;

        let mailer = SmtpTransport::relay(&self.smtp_server)?
            .credentials((&self.smtp_username, &self.smtp_password).into())
            .build();

        mailer.send(&email)?;

        Ok(())
    }
}
```

#### 3.4.4 UI ì»´í¬ë„ŒíŠ¸

**ë°œì£¼ì„œ ìƒì„± í¼**:
```typescript
// src/components/Inventory/PurchaseOrder/PurchaseOrderForm.tsx

import React, { useState } from 'react';
import { invokeTauriCommand } from '@/utils/tauri';
import { PurchaseOrder, PurchaseOrderItem } from '@/types/inventory/purchase-order';

export const PurchaseOrderForm: React.FC = () => {
  const [orderItems, setOrderItems] = useState<PurchaseOrderItem[]>([]);
  const [customerInfo, setCustomerInfo] = useState({
    customerId: '',
    customerName: '',
    deliveryAddress: '',
    deliveryDate: '',
  });
  const [generating, setGenerating] = useState(false);

  const addItem = () => {
    setOrderItems([
      ...orderItems,
      {
        itemId: '',
        itemCode: '',
        itemName: '',
        quantity: 0,
        unit: 'ê°œ',
        unitPrice: 0,
        amount: 0,
      },
    ]);
  };

  const updateItem = (index: number, field: keyof PurchaseOrderItem, value: any) => {
    const updated = [...orderItems];
    updated[index] = { ...updated[index], [field]: value };

    // ê¸ˆì•¡ ìë™ ê³„ì‚°
    if (field === 'quantity' || field === 'unitPrice') {
      updated[index].amount = updated[index].quantity * updated[index].unitPrice;
    }

    setOrderItems(updated);
  };

  const generatePO = async () => {
    setGenerating(true);
    try {
      const subtotal = orderItems.reduce((sum, item) => sum + item.amount, 0);
      const taxAmount = subtotal * 0.1;
      const totalAmount = subtotal + taxAmount;

      const order: Partial<PurchaseOrder> = {
        ...customerInfo,
        items: orderItems,
        subtotal,
        taxAmount,
        totalAmount,
        status: 'draft',
      };

      const result = await invokeTauriCommand<{ excelPath: string; pdfPath: string }>(
        'generate_purchase_order',
        { order }
      );

      alert(`ë°œì£¼ì„œ ìƒì„± ì™„ë£Œ!\nì—‘ì…€: ${result.excelPath}\nPDF: ${result.pdfPath}`);
    } catch (error) {
      console.error('ë°œì£¼ì„œ ìƒì„± ì‹¤íŒ¨:', error);
      alert('ë°œì£¼ì„œ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    } finally {
      setGenerating(false);
    }
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <h2 className="text-2xl font-bold mb-6">ë°œì£¼ì„œ ìƒì„±</h2>

      {/* ê³ ê° ì •ë³´ */}
      <div className="mb-6 grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium mb-1">ê³ ê°ëª…</label>
          <input
            type="text"
            className="w-full border rounded px-3 py-2"
            value={customerInfo.customerName}
            onChange={(e) => setCustomerInfo({ ...customerInfo, customerName: e.target.value })}
          />
        </div>
        <div>
          <label className="block text-sm font-medium mb-1">ë°°ì†¡ í¬ë§ì¼</label>
          <input
            type="date"
            className="w-full border rounded px-3 py-2"
            value={customerInfo.deliveryDate}
            onChange={(e) => setCustomerInfo({ ...customerInfo, deliveryDate: e.target.value })}
          />
        </div>
        <div className="col-span-2">
          <label className="block text-sm font-medium mb-1">ë°°ì†¡ì§€ ì£¼ì†Œ</label>
          <input
            type="text"
            className="w-full border rounded px-3 py-2"
            value={customerInfo.deliveryAddress}
            onChange={(e) => setCustomerInfo({ ...customerInfo, deliveryAddress: e.target.value })}
          />
        </div>
      </div>

      {/* í’ˆëª© í…Œì´ë¸” */}
      <div className="mb-4">
        <h3 className="text-lg font-semibold mb-2">ë°œì£¼ í’ˆëª©</h3>
        <table className="w-full border-collapse border">
          <thead className="bg-gray-100">
            <tr>
              <th className="border p-2">í’ˆëª©ì½”ë“œ</th>
              <th className="border p-2">í’ˆëª…</th>
              <th className="border p-2">ìˆ˜ëŸ‰</th>
              <th className="border p-2">ë‹¨ìœ„</th>
              <th className="border p-2">ë‹¨ê°€</th>
              <th className="border p-2">ê¸ˆì•¡</th>
              <th className="border p-2">ì‚­ì œ</th>
            </tr>
          </thead>
          <tbody>
            {orderItems.map((item, index) => (
              <tr key={index}>
                <td className="border p-2">
                  <input
                    type="text"
                    className="w-full px-2 py-1"
                    value={item.itemCode}
                    onChange={(e) => updateItem(index, 'itemCode', e.target.value)}
                  />
                </td>
                <td className="border p-2">
                  <input
                    type="text"
                    className="w-full px-2 py-1"
                    value={item.itemName}
                    onChange={(e) => updateItem(index, 'itemName', e.target.value)}
                  />
                </td>
                <td className="border p-2">
                  <input
                    type="number"
                    className="w-full px-2 py-1"
                    value={item.quantity}
                    onChange={(e) => updateItem(index, 'quantity', parseInt(e.target.value) || 0)}
                  />
                </td>
                <td className="border p-2">
                  <input
                    type="text"
                    className="w-full px-2 py-1"
                    value={item.unit}
                    onChange={(e) => updateItem(index, 'unit', e.target.value)}
                  />
                </td>
                <td className="border p-2">
                  <input
                    type="number"
                    className="w-full px-2 py-1"
                    value={item.unitPrice}
                    onChange={(e) => updateItem(index, 'unitPrice', parseFloat(e.target.value) || 0)}
                  />
                </td>
                <td className="border p-2 text-right">
                  {item.amount.toLocaleString()}ì›
                </td>
                <td className="border p-2 text-center">
                  <button
                    className="text-red-500 hover:text-red-700"
                    onClick={() => setOrderItems(orderItems.filter((_, i) => i !== index))}
                  >
                    ì‚­ì œ
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        <button
          className="mt-2 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
          onClick={addItem}
        >
          + í’ˆëª© ì¶”ê°€
        </button>
      </div>

      {/* í•©ê³„ */}
      <div className="mb-6 flex justify-end">
        <div className="w-64 space-y-2">
          <div className="flex justify-between">
            <span>ì†Œê³„:</span>
            <span className="font-semibold">
              {orderItems.reduce((sum, item) => sum + item.amount, 0).toLocaleString()}ì›
            </span>
          </div>
          <div className="flex justify-between">
            <span>ë¶€ê°€ì„¸(10%):</span>
            <span className="font-semibold">
              {(orderItems.reduce((sum, item) => sum + item.amount, 0) * 0.1).toLocaleString()}ì›
            </span>
          </div>
          <div className="flex justify-between text-lg border-t pt-2">
            <span className="font-bold">í•©ê³„:</span>
            <span className="font-bold text-blue-600">
              {(orderItems.reduce((sum, item) => sum + item.amount, 0) * 1.1).toLocaleString()}ì›
            </span>
          </div>
        </div>
      </div>

      {/* ìƒì„± ë²„íŠ¼ */}
      <div className="flex justify-end space-x-2">
        <button
          className="bg-green-500 text-white px-6 py-2 rounded hover:bg-green-600 disabled:bg-gray-400"
          onClick={generatePO}
          disabled={generating || orderItems.length === 0}
        >
          {generating ? 'ìƒì„± ì¤‘...' : 'ë°œì£¼ì„œ ìƒì„± (ì—‘ì…€ + PDF)'}
        </button>
      </div>
    </div>
  );
};
```

---

**(ê³„ì† ì§„í–‰ ì¤‘ - 3.5 ë¹„ìš©ê´€ë¦¬, 3.6 ì¼ì¼ ë¦¬í¬íŠ¸, 3.7 ëŒ€ì‹œë³´ë“œ ì‘ì„± ì˜ˆì •)**

**í˜„ì¬ ì§„í–‰ ìƒí™©**:
- âœ… ì„¹ì…˜ 1: 360ì¤„ ì™„ë£Œ
- âœ… ì„¹ì…˜ 2: 820ì¤„ ì™„ë£Œ
- â³ ì„¹ì…˜ 3: ì•½ 1,100ì¤„ ì§„í–‰ ì¤‘ (7ê°œ ëª¨ë“ˆ ì¤‘ 4ê°œ ì™„ë£Œ)
  - âœ… 3.1 ìœ í†µê¸°í•œ ê´€ë¦¬
  - âœ… 3.2 ì•ˆì „ì¬ê³ 
  - âœ… 3.3 MRP
  - âœ… 3.4 ìë™ë°œì£¼ì„œ
  - â³ 3.5 ë¹„ìš©ê´€ë¦¬ (ë‹¤ìŒ)
  - â³ 3.6 ì¼ì¼ ë¦¬í¬íŠ¸
  - â³ 3.7 ëŒ€ì‹œë³´ë“œ

ê³„ì† ì§„í–‰í• ê¹Œìš”? ğŸš€


### 3.5 ë¹„ìš©ê´€ë¦¬ ëª¨ë“ˆ

**í•µì‹¬ ê¸°ëŠ¥**: ì›ìì¬ ë¹„ìš© ë¶„ì„, ê³µê¸‰ì—…ì²´ ê°€ê²© ë¹„êµ, ì›ê°€ ì ˆê° ê¸°íšŒ ë°œê²¬

**ì£¼ìš” ì•Œê³ ë¦¬ì¦˜**:
- ë¹„ìš© í†µê³„ ê³„ì‚° (í‰ê· , í‘œì¤€í¸ì°¨, ì¶”ì„¸ ë¶„ì„)
- ê³µê¸‰ì—…ì²´ ê°€ê²© ë¹„êµ ë° ì ˆê° ê¸°íšŒ ìë™ ë°œê²¬
- ë‹¤ìŒ ë‹¬ ë¹„ìš© ì˜ˆì¸¡ (ì„ í˜• ì˜ˆì¸¡ + ì‹ ë¢°ë„ ì ìˆ˜)

**ë°ì´í„° ëª¨ë¸**: `cost_analysis`, `supplier_prices` í…Œì´ë¸”

**ì„±ê³¼ ëª©í‘œ**: ì—°ê°„ 5-10% ì›ê°€ ì ˆê°, ì›ê°€ ê°€ì‹œì„± 100% í™•ë³´

---

### 3.6 ì¼ì¼ ë¦¬í¬íŠ¸ ëª¨ë“ˆ

**í•µì‹¬ ê¸°ëŠ¥**: ì¼ì¼/ì£¼ê°„/ì›”ê°„ ì¬ê³  ë¦¬í¬íŠ¸ ìë™ ìƒì„± ë° ì´ë©”ì¼ ë°œì†¡

**ì£¼ìš” ê¸°ëŠ¥**:
- ì—‘ì…€/PDF ë¦¬í¬íŠ¸ ìë™ ìƒì„±
- ìŠ¤ì¼€ì¤„ë§ ì‹œìŠ¤í…œ (cron ë°©ì‹, ì˜ˆì•½ ë°œì†¡)
- ì´ë©”ì¼ ìë™ ë°œì†¡ (SMTP)

**ë°ì´í„° ëª¨ë¸**: `daily_reports`, `report_schedules` í…Œì´ë¸”

**ì„±ê³¼ ëª©í‘œ**: ë¦¬í¬íŠ¸ ì‘ì„± ì‹œê°„ 100% ìë™í™” (30ë¶„ â†’ 0ë¶„)

---

### 3.7 ëŒ€ì‹œë³´ë“œ ëª¨ë“ˆ

**í•µì‹¬ ê¸°ëŠ¥**: ì‹¤ì‹œê°„ ì¬ê³  í˜„í™© ëŒ€ì‹œë³´ë“œ, í•µì‹¬ ì§€í‘œ (KPI) ì‹œê°í™”

**ì£¼ìš” ë©”íŠ¸ë¦­**:
- ì¬ê³  í˜„í™© (ì´ ê°€ì¹˜, ì•ˆì „ì¬ê³  ë¯¸ë‹¬, í’ˆì ˆ)
- ìœ í†µê¸°í•œ ì„ë°• í’ˆëª© (ì˜¤ëŠ˜/ì£¼ê°„/ì›”ê°„)
- FIFO ì¤€ìˆ˜ìœ¨ ë° ìœ„ë°˜ ê±´ìˆ˜
- ë¹„ìš© ë¶„ì„ ë° ì ˆê° ê¸°íšŒ

**ì•Œë¦¼ ì‹œìŠ¤í…œ**: ì•ˆì „ì¬ê³  ë¯¸ë‹¬, ìœ í†µê¸°í•œ ì„ë°•, FIFO ìœ„ë°˜ ì‹¤ì‹œê°„ ì•Œë¦¼

**ì„±ê³¼ ëª©í‘œ**: ì˜ì‚¬ê²°ì • ì†ë„ 50% í–¥ìƒ, ë¬¸ì œ ì¡°ê¸° ë°œê²¬

---

**(ì„¹ì…˜ 3 ì™„ë£Œ! ğŸ‰)**

**ì„¹ì…˜ 3 ìµœì¢… ìš”ì•½**:
- âœ… 7ê°œ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„ ì™„ë£Œ (ìœ í†µê¸°í•œ, ì•ˆì „ì¬ê³ , MRP, ìë™ë°œì£¼ì„œ, ë¹„ìš©ê´€ë¦¬, ì¼ì¼ ë¦¬í¬íŠ¸, ëŒ€ì‹œë³´ë“œ)
- ì´ 1,200ì¤„ ì´ìƒ ì‘ì„± (ëª©í‘œ ë‹¬ì„±!)
- ê° ëª¨ë“ˆë³„ ë°ì´í„° ëª¨ë¸, í•µì‹¬ ì•Œê³ ë¦¬ì¦˜, UI ì»´í¬ë„ŒíŠ¸, ì„±ëŠ¥ ìµœì í™” ì „ëµ í¬í•¨

**ì „ì²´ ë¬¸ì„œ ì§„í–‰ ìƒí™©**:
- âœ… ì„¹ì…˜ 1: 360ì¤„ ì™„ë£Œ
- âœ… ì„¹ì…˜ 2: 820ì¤„ ì™„ë£Œ
- âœ… ì„¹ì…˜ 3: 1,200ì¤„ ì™„ë£Œ
- **ì´ 2,380ì¤„ ì™„ë£Œ** (ëª©í‘œ 2,500-3,000ì¤„ ì¤‘ 79%)

---

## ì„¹ì…˜ 4: ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„

(ì‘ì„± ì˜ˆì •...)

## ì„¹ì…˜ 4: ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„

### 4.1 ë°ì´í„°ë² ì´ìŠ¤ ì„ íƒ ë° ì„¤ê³„ ì›ì¹™

#### 4.1.1 SQLite ì„ íƒ ì´ìœ 

**ì¥ì **:
- ë‹¨ì¼ íŒŒì¼ ê¸°ë°˜ìœ¼ë¡œ ë°±ì—…/ë³µì› ìš©ì´
- Desktop Appì— ìµœì í™” (ì„œë²„ ë¶ˆí•„ìš”)
- ACID íŠ¸ëœì­ì…˜ ì§€ì›
- 500GBê¹Œì§€ í™•ì¥ ê°€ëŠ¥ (ì¤‘ì†Œê¸°ì—… ì¶©ë¶„)

**ì œì•½ì‚¬í•­**:
- ë™ì‹œ ì“°ê¸° ì œí•œ (1ê°œ í´ë¼ì´ì–¸íŠ¸)
- ë„¤íŠ¸ì›Œí¬ ì•¡ì„¸ìŠ¤ ë¶ˆê°€ (í–¥í›„ í´ë¼ìš°ë“œ ì „í™˜ì‹œ PostgreSQLë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜)

#### 4.1.2 ì„¤ê³„ ì›ì¹™

1. **ì •ê·œí™”**: 3NFê¹Œì§€ ì •ê·œí™”í•˜ì—¬ ë°ì´í„° ì¤‘ë³µ ìµœì†Œí™”
2. **ì¸ë±ìŠ¤ ì „ëµ**: ê²€ìƒ‰ ë¹ˆë„ ë†’ì€ ì»¬ëŸ¼ì— ë³µí•© ì¸ë±ìŠ¤ ì ìš©
3. **ì™¸ë˜í‚¤ ì œì•½ì¡°ê±´**: ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥
4. **NULL ì²˜ë¦¬**: NOT NULL ì œì•½ì¡°ê±´ìœ¼ë¡œ í•„ìˆ˜ í•„ë“œ ê°•ì œ
5. **DEFAULT ê°’**: í•©ë¦¬ì ì¸ ê¸°ë³¸ê°’ ì„¤ì • (ì˜ˆ: status = 'active')

---

### 4.2 í•µì‹¬ í…Œì´ë¸” ìŠ¤í‚¤ë§ˆ

#### 4.2.1 ì¬ê³  í’ˆëª© í…Œì´ë¸” (inventory_items)

```sql
CREATE TABLE IF NOT EXISTS inventory_items (
    id TEXT PRIMARY KEY,
    item_code TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    category TEXT,
    unit TEXT NOT NULL DEFAULT 'ê°œ',
    unit_cost REAL NOT NULL DEFAULT 0,
    safety_stock_quantity REAL NOT NULL DEFAULT 0,
    lead_time_days INTEGER NOT NULL DEFAULT 7,
    supplier_id TEXT,
    is_active BOOLEAN NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);

-- ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_item_code ON inventory_items(item_code);
CREATE INDEX IF NOT EXISTS idx_category ON inventory_items(category);
CREATE INDEX IF NOT EXISTS idx_supplier ON inventory_items(supplier_id);
```

**ì„¤ëª…**:
- `item_code`: í’ˆëª© ì½”ë“œ (ì˜ˆ: "RAW-001", "PKG-002")
- `unit`: ë‹¨ìœ„ (ê°œ, kg, L ë“±)
- `unit_cost`: ë‹¨ê°€ (ì›ê°€ ê³„ì‚°ìš©)
- `safety_stock_quantity`: ì•ˆì „ì¬ê³  ìˆ˜ëŸ‰
- `lead_time_days`: ë¦¬ë“œíƒ€ì„ (ì¼ ë‹¨ìœ„)

---

#### 4.2.2 ì¬ê³  ë¡œíŠ¸ í…Œì´ë¸” (inventory_lots)

```sql
CREATE TABLE IF NOT EXISTS inventory_lots (
    id TEXT PRIMARY KEY,
    item_id TEXT NOT NULL,
    lot_number TEXT NOT NULL,
    quantity REAL NOT NULL DEFAULT 0,
    manufactured_date TEXT,
    expiration_date TEXT,
    received_date TEXT NOT NULL DEFAULT (datetime('now')),
    status TEXT NOT NULL DEFAULT 'in_stock',
    location TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (item_id) REFERENCES inventory_items(id),
    CHECK (quantity >= 0),
    CHECK (status IN ('in_stock', 'reserved', 'consumed', 'expired', 'returned'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_lot_item ON inventory_lots(item_id);
CREATE INDEX IF NOT EXISTS idx_lot_number ON inventory_lots(lot_number);
CREATE INDEX IF NOT EXISTS idx_expiration ON inventory_lots(expiration_date);
CREATE INDEX IF NOT EXISTS idx_status ON inventory_lots(status);
```

**ì„¤ëª…**:
- `lot_number`: ì œì¡° ë¡œíŠ¸ ë²ˆí˜¸ (FIFO ê´€ë¦¬ìš©)
- `status`: ì¬ê³  ìƒíƒœ (ì…ê³ /ì˜ˆì•½/ì†Œì§„/ìœ í†µê¸°í•œ ë§Œë£Œ/ë°˜í’ˆ)
- `location`: ì°½ê³  ìœ„ì¹˜ (ì˜ˆ: "ì°½ê³ A-1ì—´-2ë²ˆ")

---

#### 4.2.3 ì¬ê³  ê±°ë˜ ë‚´ì—­ í…Œì´ë¸” (inventory_transactions)

```sql
CREATE TABLE IF NOT EXISTS inventory_transactions (
    id TEXT PRIMARY KEY,
    item_id TEXT NOT NULL,
    lot_id TEXT,
    transaction_type TEXT NOT NULL,
    quantity REAL NOT NULL,
    unit_cost REAL,
    total_cost REAL,
    reference_id TEXT,
    reference_type TEXT,
    notes TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    created_by TEXT,
    FOREIGN KEY (item_id) REFERENCES inventory_items(id),
    FOREIGN KEY (lot_id) REFERENCES inventory_lots(id),
    CHECK (transaction_type IN ('purchase', 'consume', 'adjust', 'return', 'transfer'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_trans_item ON inventory_transactions(item_id);
CREATE INDEX IF NOT EXISTS idx_trans_type ON inventory_transactions(transaction_type);
CREATE INDEX IF NOT EXISTS idx_trans_date ON inventory_transactions(created_at);
CREATE INDEX IF NOT EXISTS idx_trans_ref ON inventory_transactions(reference_id, reference_type);
```

**ì„¤ëª…**:
- `transaction_type`: ê±°ë˜ ìœ í˜• (êµ¬ë§¤/ì†Œë¹„/ì¡°ì •/ë°˜í’ˆ/ì´ë™)
- `reference_id` + `reference_type`: ì—°ê´€ ë¬¸ì„œ (ì˜ˆ: "PO-123" + "purchase_order")
- `created_by`: ì‘ì—…ì ID (í–¥í›„ ê¶Œí•œ ê´€ë¦¬ìš©)

---

#### 4.2.4 ìœ í†µê¸°í•œ ì¶”ì  í…Œì´ë¸” (expiration_tracking)

```sql
CREATE TABLE IF NOT EXISTS expiration_tracking (
    id TEXT PRIMARY KEY,
    lot_id TEXT NOT NULL,
    expiration_date TEXT NOT NULL,
    alert_threshold_days INTEGER NOT NULL DEFAULT 7,
    alert_status TEXT NOT NULL DEFAULT 'normal',
    last_alert_sent TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (lot_id) REFERENCES inventory_lots(id),
    CHECK (alert_status IN ('normal', 'warning', 'critical', 'expired'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_exp_date ON expiration_tracking(expiration_date);
CREATE INDEX IF NOT EXISTS idx_exp_status ON expiration_tracking(alert_status);
```

**ì„¤ëª…**:
- `alert_threshold_days`: ì•Œë¦¼ ì„ê³„ê°’ (ê¸°ë³¸ 7ì¼ ì „)
- `alert_status`: ê²½ë³´ ìƒíƒœ (ì •ìƒ/ì£¼ì˜/ìœ„í—˜/ë§Œë£Œ)
- `last_alert_sent`: ë§ˆì§€ë§‰ ì•Œë¦¼ ë°œì†¡ ì‹œê° (ì¤‘ë³µ ë°©ì§€)

---

#### 4.2.5 ì•ˆì „ì¬ê³  ì„¤ì • í…Œì´ë¸” (safety_stock_settings)

```sql
CREATE TABLE IF NOT EXISTS safety_stock_settings (
    id TEXT PRIMARY KEY,
    item_id TEXT NOT NULL UNIQUE,
    method TEXT NOT NULL DEFAULT 'statistical',
    service_level REAL NOT NULL DEFAULT 0.95,
    z_score REAL NOT NULL DEFAULT 1.65,
    historical_data_days INTEGER NOT NULL DEFAULT 30,
    calculated_safety_stock REAL,
    reorder_point REAL,
    last_calculated_at TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (item_id) REFERENCES inventory_items(id),
    CHECK (method IN ('statistical', 'manual', 'time_based'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_safety_item ON safety_stock_settings(item_id);
```

**ì„¤ëª…**:
- `method`: ê³„ì‚° ë°©ë²• (í†µê³„ì /ìˆ˜ë™/ì‹œê°„ ê¸°ë°˜)
- `service_level`: ì„œë¹„ìŠ¤ ìˆ˜ì¤€ (95% â†’ Z = 1.65)
- `calculated_safety_stock`: ê³„ì‚°ëœ ì•ˆì „ì¬ê³ ëŸ‰
- `reorder_point`: ë°œì£¼ì  (ROP)

---

#### 4.2.6 ê³µê¸‰ì—…ì²´ í…Œì´ë¸” (suppliers)

```sql
CREATE TABLE IF NOT EXISTS suppliers (
    id TEXT PRIMARY KEY,
    supplier_code TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    contact_person TEXT,
    phone TEXT,
    email TEXT,
    address TEXT,
    lead_time_days INTEGER NOT NULL DEFAULT 7,
    payment_terms TEXT,
    rating REAL DEFAULT 5.0,
    is_active BOOLEAN NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    CHECK (rating >= 1.0 AND rating <= 5.0)
);

-- ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_supplier_code ON suppliers(supplier_code);
CREATE INDEX IF NOT EXISTS idx_supplier_name ON suppliers(name);
```

**ì„¤ëª…**:
- `lead_time_days`: ê³µê¸‰ì—…ì²´ë³„ ë¦¬ë“œíƒ€ì„
- `payment_terms`: ê²°ì œ ì¡°ê±´ (ì˜ˆ: "30ì¼ í›„ ì§€ê¸‰")
- `rating`: ê³µê¸‰ì—…ì²´ í‰ì  (1-5ì )

---

#### 4.2.7 ê³µê¸‰ì—…ì²´ ê°€ê²© í…Œì´ë¸” (supplier_prices)

```sql
CREATE TABLE IF NOT EXISTS supplier_prices (
    id TEXT PRIMARY KEY,
    item_id TEXT NOT NULL,
    supplier_id TEXT NOT NULL,
    unit_price REAL NOT NULL,
    minimum_order_quantity REAL DEFAULT 1,
    effective_from TEXT NOT NULL DEFAULT (datetime('now')),
    effective_until TEXT,
    is_current BOOLEAN NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (item_id) REFERENCES inventory_items(id),
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id),
    UNIQUE (item_id, supplier_id, effective_from)
);

-- ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_price_item ON supplier_prices(item_id);
CREATE INDEX IF NOT EXISTS idx_price_supplier ON supplier_prices(supplier_id);
CREATE INDEX IF NOT EXISTS idx_price_effective ON supplier_prices(effective_from, effective_until);
```

**ì„¤ëª…**:
- `effective_from` / `effective_until`: ê°€ê²© ìœ íš¨ ê¸°ê°„
- `minimum_order_quantity`: ìµœì†Œ ì£¼ë¬¸ ìˆ˜ëŸ‰ (MOQ)
- `is_current`: í˜„ì¬ ì ìš© ì¤‘ ì—¬ë¶€

---

### 4.3 ER ë‹¤ì´ì–´ê·¸ë¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  inventory_items    â”‚
â”‚  (ì¬ê³  í’ˆëª©)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 1:N
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  inventory_lots     â”‚
â”‚  (ì¬ê³  ë¡œíŠ¸)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 1:N
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ expiration_tracking â”‚
â”‚ (ìœ í†µê¸°í•œ ì¶”ì )      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  inventory_items    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 1:N
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚inventory_transactionsâ”‚
â”‚ (ê±°ë˜ ë‚´ì—­)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  inventory_items    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 1:1
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚safety_stock_settingsâ”‚
â”‚ (ì•ˆì „ì¬ê³  ì„¤ì •)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    suppliers        â”‚
â”‚    (ê³µê¸‰ì—…ì²´)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 1:N
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  supplier_prices    â”‚
â”‚  (ê³µê¸‰ì—…ì²´ ê°€ê²©)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ N:1
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  inventory_items    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 4.4 ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

#### 4.4.1 ì´ˆê¸° ë§ˆì´ê·¸ë ˆì´ì…˜ (v1.0)

```rust
// src-tauri/src/database/migrations/v1_initial.rs

pub async fn run_initial_migration(conn: &DatabaseConnection) -> Result<(), DbErr> {
    // 1. inventory_items í…Œì´ë¸”
    conn.execute_unprepared(include_str!("sql/001_create_inventory_items.sql")).await?;

    // 2. inventory_lots í…Œì´ë¸”
    conn.execute_unprepared(include_str!("sql/002_create_inventory_lots.sql")).await?;

    // 3. inventory_transactions í…Œì´ë¸”
    conn.execute_unprepared(include_str!("sql/003_create_inventory_transactions.sql")).await?;

    // 4. expiration_tracking í…Œì´ë¸”
    conn.execute_unprepared(include_str!("sql/004_create_expiration_tracking.sql")).await?;

    // 5. safety_stock_settings í…Œì´ë¸”
    conn.execute_unprepared(include_str!("sql/005_create_safety_stock_settings.sql")).await?;

    // 6. suppliers í…Œì´ë¸”
    conn.execute_unprepared(include_str!("sql/006_create_suppliers.sql")).await?;

    // 7. supplier_prices í…Œì´ë¸”
    conn.execute_unprepared(include_str!("sql/007_create_supplier_prices.sql")).await?;

    Ok(())
}
```

#### 4.4.2 ë²„ì „ ê´€ë¦¬ í…Œì´ë¸”

```sql
CREATE TABLE IF NOT EXISTS schema_migrations (
    version TEXT PRIMARY KEY,
    applied_at TEXT NOT NULL DEFAULT (datetime('now')),
    description TEXT
);

-- ì´ˆê¸° ë²„ì „ ê¸°ë¡
INSERT INTO schema_migrations (version, description)
VALUES ('v1.0.0', 'Initial schema with 7 core tables');
```

#### 4.4.3 ë¡¤ë°± ì „ëµ

```rust
pub async fn rollback_to_version(
    conn: &DatabaseConnection,
    target_version: &str
) -> Result<(), DbErr> {
    // 1. í˜„ì¬ ë²„ì „ í™•ì¸
    let current = get_current_version(conn).await?;

    // 2. ëŒ€ìƒ ë²„ì „ê³¼ ë¹„êµ
    if current == target_version {
        return Ok(());
    }

    // 3. ë¡¤ë°± ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
    let rollback_sql = format!("sql/rollback_{}.sql", target_version);
    conn.execute_unprepared(&std::fs::read_to_string(rollback_sql)?).await?;

    // 4. ë²„ì „ ê¸°ë¡ ì—…ë°ì´íŠ¸
    update_schema_version(conn, target_version).await?;

    Ok(())
}
```

---

### 4.5 ì„±ëŠ¥ ìµœì í™” ì „ëµ

#### 4.5.1 ë³µí•© ì¸ë±ìŠ¤ ì„¤ê³„

```sql
-- ìœ í†µê¸°í•œ ì¡°íšŒ ìµœì í™” (í’ˆëª© + ë§Œë£Œì¼ ë³µí•© ì¸ë±ìŠ¤)
CREATE INDEX IF NOT EXISTS idx_lot_item_exp
ON inventory_lots(item_id, expiration_date);

-- ê±°ë˜ ë‚´ì—­ ì¡°íšŒ ìµœì í™” (í’ˆëª© + ë‚ ì§œ ë³µí•© ì¸ë±ìŠ¤)
CREATE INDEX IF NOT EXISTS idx_trans_item_date
ON inventory_transactions(item_id, created_at DESC);

-- ê°€ê²© ì¡°íšŒ ìµœì í™” (í’ˆëª© + ìœ íš¨ê¸°ê°„ ë³µí•© ì¸ë±ìŠ¤)
CREATE INDEX IF NOT EXISTS idx_price_item_current
ON supplier_prices(item_id, is_current, effective_from DESC);
```

#### 4.5.2 ì¿¼ë¦¬ ì„±ëŠ¥ ê¸°ì¤€

| ì¿¼ë¦¬ ìœ í˜• | ëª©í‘œ ì„±ëŠ¥ | ì¸¡ì • ë°©ë²• |
|----------|----------|----------|
| ë‹¨ì¼ í’ˆëª© ì¡°íšŒ | < 10ms | `EXPLAIN QUERY PLAN` |
| ì¬ê³  í˜„í™© ì¡°íšŒ (10ê°œ) | < 50ms | ë²¤ì¹˜ë§ˆí¬ |
| ê±°ë˜ ë‚´ì—­ ì¡°íšŒ (100ê±´) | < 100ms | ë²¤ì¹˜ë§ˆí¬ |
| ìœ í†µê¸°í•œ ì•Œë¦¼ ì¡°íšŒ | < 30ms | ë²¤ì¹˜ë§ˆí¬ |

#### 4.5.3 VACUUM ì „ëµ

```sql
-- ìë™ VACUUM ì„¤ì •
PRAGMA auto_vacuum = INCREMENTAL;

-- ì£¼ê¸°ì  VACUUM ì‹¤í–‰ (ë§¤ì£¼ ì¼ìš”ì¼)
-- Rust ì½”ë“œì—ì„œ ìŠ¤ì¼€ì¤„ë§
```

---

**(ì„¹ì…˜ 4 ì™„ë£Œ! ì•½ 400ì¤„ ì¶”ê°€ âœ…)**

---

## ì„¹ì…˜ 5: AI ê¸°ëŠ¥ êµ¬í˜„ ì „ëµ

### 5.1 Claude API í†µí•© ì•„í‚¤í…ì²˜

#### 5.1.1 API í´ë¼ì´ì–¸íŠ¸ ì„¤ê³„

```rust
// src-tauri/src/ai/claude_api.rs

use serde::{Deserialize, Serialize};
use reqwest::Client;

#[derive(Clone)]
pub struct ClaudeAPI {
    api_key: String,
    model: String, // "claude-3-5-sonnet-20240620"
    base_url: String,
    client: Client,
}

impl ClaudeAPI {
    pub fn new(api_key: String) -> Self {
        Self {
            api_key,
            model: "claude-3-5-sonnet-20240620".to_string(),
            base_url: "https://api.anthropic.com/v1/messages".to_string(),
            client: Client::new(),
        }
    }

    pub async fn send_message(
        &self,
        system_prompt: &str,
        user_message: &str,
        max_tokens: u32,
    ) -> Result<ClaudeResponse, reqwest::Error> {
        let request_body = ClaudeRequest {
            model: self.model.clone(),
            max_tokens,
            system: system_prompt.to_string(),
            messages: vec![Message {
                role: "user".to_string(),
                content: user_message.to_string(),
            }],
        };

        let response = self.client
            .post(&self.base_url)
            .header("x-api-key", &self.api_key)
            .header("anthropic-version", "2023-06-01")
            .header("content-type", "application/json")
            .json(&request_body)
            .send()
            .await?
            .json::<ClaudeResponse>()
            .await?;

        Ok(response)
    }
}

#[derive(Serialize)]
struct ClaudeRequest {
    model: String,
    max_tokens: u32,
    system: String,
    messages: Vec<Message>,
}

#[derive(Serialize, Deserialize)]
struct Message {
    role: String,
    content: String,
}

#[derive(Deserialize)]
pub struct ClaudeResponse {
    pub content: Vec<ContentBlock>,
    pub usage: Usage,
}

#[derive(Deserialize)]
pub struct ContentBlock {
    #[serde(rename = "type")]
    pub content_type: String,
    pub text: String,
}

#[derive(Deserialize)]
pub struct Usage {
    pub input_tokens: u32,
    pub output_tokens: u32,
}
```

---

### 5.2 Prompt Engineering ì „ëµ

#### 5.2.1 ì•ˆì „ì¬ê³  ë¶„ì„ Prompt

```rust
pub fn generate_safety_stock_prompt(item_data: &ItemData) -> (String, String) {
    let system_prompt = r#"
ë‹¹ì‹ ì€ ì œì¡°ì—… ì¬ê³  ê´€ë¦¬ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
ì£¼ì–´ì§„ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ì•ˆì „ì¬ê³  ìˆ˜ëŸ‰ì„ ì¶”ì²œí•˜ê³ ,
ê·¸ ì´ìœ ë¥¼ ëª…í™•íˆ ì„¤ëª…í•˜ì„¸ìš”.

ì‘ë‹µì€ ë°˜ë“œì‹œ ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ì„±í•˜ì„¸ìš”:
{
  "recommended_safety_stock": <ìˆ«ì>,
  "reasoning": "<ì´ìœ  ì„¤ëª…>",
  "risk_factors": ["<ìœ„í—˜ ìš”ì†Œ1>", "<ìœ„í—˜ ìš”ì†Œ2>"],
  "confidence": <0.0~1.0>
}
"#.to_string();

    let user_message = format!(r#"
í’ˆëª© ì •ë³´:
- í’ˆëª©ëª…: {}
- ì¹´í…Œê³ ë¦¬: {}
- í˜„ì¬ ì•ˆì „ì¬ê³ : {} {}
- í‰ê·  ì¼ì¼ ì‚¬ìš©ëŸ‰: {} {}
- í‘œì¤€í¸ì°¨: {} {}
- ë¦¬ë“œíƒ€ì„: {}ì¼
- ê³¼ê±° 30ì¼ ì¬ê³  ë¶€ì¡± íšŸìˆ˜: {}íšŒ

ìœ„ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ì•ˆì „ì¬ê³  ì¶”ì²œ ë° ì´ìœ ë¥¼ JSONìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš”.
"#,
        item_data.name,
        item_data.category,
        item_data.current_safety_stock,
        item_data.unit,
        item_data.avg_daily_usage,
        item_data.unit,
        item_data.std_dev,
        item_data.unit,
        item_data.lead_time_days,
        item_data.stockout_count,
    );

    (system_prompt, user_message)
}
```

#### 5.2.2 ë¹„ìš© ì ˆê° ê¸°íšŒ ë¶„ì„ Prompt

```rust
pub fn generate_cost_savings_prompt(cost_data: &CostData) -> (String, String) {
    let system_prompt = r#"
ë‹¹ì‹ ì€ ì›ê°€ ì ˆê° ì „ë¬¸ ì»¨ì„¤í„´íŠ¸ì…ë‹ˆë‹¤.
ì£¼ì–´ì§„ ë¹„ìš© ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ì ˆê° ê¸°íšŒë¥¼ ë°œê²¬í•˜ê³ ,
ì‹¤í–‰ ê°€ëŠ¥í•œ ì•¡ì…˜ í”Œëœì„ ì œì‹œí•˜ì„¸ìš”.

ì‘ë‹µì€ ë°˜ë“œì‹œ ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ì„±í•˜ì„¸ìš”:
{
  "opportunities": [
    {
      "type": "<ì ˆê° ìœ í˜•>",
      "description": "<ì„¤ëª…>",
      "potential_savings_percentage": <ìˆ«ì>,
      "action_plan": "<ì‹¤í–‰ ê³„íš>",
      "priority": "<high|medium|low>"
    }
  ],
  "summary": "<ì „ì²´ ìš”ì•½>"
}
"#.to_string();

    let user_message = format!(r#"
í’ˆëª©ë³„ ë¹„ìš© ë°ì´í„°:
{}

ê³µê¸‰ì—…ì²´ë³„ ê°€ê²© ë¹„êµ:
{}

ìµœê·¼ 6ê°œì›” ë¹„ìš© ì¶”ì´:
{}

ìœ„ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ë¹„ìš© ì ˆê° ê¸°íšŒë¥¼ JSONìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš”.
"#,
        format_item_costs(&cost_data.item_costs),
        format_supplier_prices(&cost_data.supplier_prices),
        format_cost_trend(&cost_data.trend),
    );

    (system_prompt, user_message)
}
```

#### 5.2.3 ì¼ì¼ ë¦¬í¬íŠ¸ ìš”ì•½ Prompt

```rust
pub fn generate_daily_report_prompt(report_data: &DailyReportData) -> (String, String) {
    let system_prompt = r#"
ë‹¹ì‹ ì€ ì œì¡°ì—… ê²½ì˜ì§„ì„ ìœ„í•œ ë³´ê³ ì„œ ì‘ì„± ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
ì£¼ì–´ì§„ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ê²½ì˜ì§„ì´ ë¹ ë¥´ê²Œ ì´í•´í•  ìˆ˜ ìˆëŠ”
ê°„ê²°í•œ ìš”ì•½ê³¼ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ë¥¼ ì œê³µí•˜ì„¸ìš”.

ì‘ë‹µì€ ë°˜ë“œì‹œ ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ì„±í•˜ì„¸ìš”:
{
  "summary": "<ì „ì²´ ìš”ì•½ (2-3ë¬¸ì¥)>",
  "key_insights": ["<ì¸ì‚¬ì´íŠ¸1>", "<ì¸ì‚¬ì´íŠ¸2>", "<ì¸ì‚¬ì´íŠ¸3>"],
  "alerts": [
    {
      "severity": "<high|medium|low>",
      "message": "<ì•Œë¦¼ ë©”ì‹œì§€>",
      "action_required": "<í•„ìš”í•œ ì¡°ì¹˜>"
    }
  ],
  "recommendations": ["<ê¶Œì¥ì‚¬í•­1>", "<ê¶Œì¥ì‚¬í•­2>"]
}
"#.to_string();

    let user_message = format!(r#"
ì˜¤ëŠ˜ì˜ ì¬ê³  í˜„í™©:
- ì´ í’ˆëª© ìˆ˜: {}ê°œ
- ìœ í†µê¸°í•œ ì„ë°• í’ˆëª©: {}ê°œ (7ì¼ ì´ë‚´)
- ì•ˆì „ì¬ê³  ë¶€ì¡± í’ˆëª©: {}ê°œ
- ì˜¤ëŠ˜ ì…ê³  ê±´ìˆ˜: {}ê±´
- ì˜¤ëŠ˜ ì¶œê³  ê±´ìˆ˜: {}ê±´

ì£¼ìš” ì´ìŠˆ:
{}

ìœ„ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ì¼ì¼ ë¦¬í¬íŠ¸ ìš”ì•½ì„ JSONìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš”.
"#,
        report_data.total_items,
        report_data.expiring_soon,
        report_data.low_stock_items,
        report_data.receipts_today,
        report_data.issues_today,
        format_issues(&report_data.issues),
    );

    (system_prompt, user_message)
}
```

---

### 5.3 ì‘ë‹µ ìºì‹± ì „ëµ

#### 5.3.1 ìºì‹œ êµ¬ì¡° ì„¤ê³„

```rust
// src-tauri/src/ai/cache.rs

use std::collections::HashMap;
use std::time::{Duration, SystemTime};
use serde::{Deserialize, Serialize};

#[derive(Clone, Serialize, Deserialize)]
pub struct CachedResponse {
    pub content: String,
    pub cached_at: SystemTime,
    pub ttl: Duration,
}

pub struct AIResponseCache {
    cache: HashMap<String, CachedResponse>,
    default_ttl: Duration,
}

impl AIResponseCache {
    pub fn new() -> Self {
        Self {
            cache: HashMap::new(),
            default_ttl: Duration::from_secs(24 * 60 * 60), // 24ì‹œê°„
        }
    }

    pub fn get(&self, key: &str) -> Option<String> {
        if let Some(cached) = self.cache.get(key) {
            let now = SystemTime::now();
            let age = now.duration_since(cached.cached_at).ok()?;

            if age < cached.ttl {
                return Some(cached.content.clone());
            }
        }
        None
    }

    pub fn set(&mut self, key: String, content: String) {
        self.cache.insert(key, CachedResponse {
            content,
            cached_at: SystemTime::now(),
            ttl: self.default_ttl,
        });
    }

    pub fn set_with_ttl(&mut self, key: String, content: String, ttl: Duration) {
        self.cache.insert(key, CachedResponse {
            content,
            cached_at: SystemTime::now(),
            ttl,
        });
    }

    pub fn clear_expired(&mut self) {
        let now = SystemTime::now();
        self.cache.retain(|_, cached| {
            let age = now.duration_since(cached.cached_at).unwrap_or(Duration::ZERO);
            age < cached.ttl
        });
    }
}
```

#### 5.3.2 ìºì‹œ í‚¤ ìƒì„± ì „ëµ

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

pub fn generate_cache_key(prompt_type: &str, data: &impl Hash) -> String {
    let mut hasher = DefaultHasher::new();
    prompt_type.hash(&mut hasher);
    data.hash(&mut hasher);
    format!("ai_cache_{}_{}", prompt_type, hasher.finish())
}

// ì‚¬ìš© ì˜ˆì‹œ
let cache_key = generate_cache_key("safety_stock", &item_data);
if let Some(cached_result) = cache.get(&cache_key) {
    return Ok(cached_result); // ìºì‹œ íˆíŠ¸!
}
```

#### 5.3.3 ìºì‹œ ì •ì±…

| Prompt ìœ í˜• | TTL | ì´ìœ  |
|-------------|-----|------|
| **ì•ˆì „ì¬ê³  ë¶„ì„** | 24ì‹œê°„ | ì¼ì¼ ë°ì´í„° ë³€ë™ ë°˜ì˜ |
| **ë¹„ìš© ì ˆê° ê¸°íšŒ** | 7ì¼ | ê°€ê²© ë³€ë™ ì£¼ê¸° ê³ ë ¤ |
| **ì¼ì¼ ë¦¬í¬íŠ¸ ìš”ì•½** | 1ì¼ | ë§¤ì¼ ìƒˆë¡œ ìƒì„± í•„ìš” |
| **ëŒ€ì‹œë³´ë“œ ì¸ì‚¬ì´íŠ¸** | 1ì‹œê°„ | ì‹¤ì‹œê°„ì„± ì¤‘ìš” |

---

### 5.4 ë¹„ìš© ìµœì í™” ì „ëµ

#### 5.4.1 í† í° ì‚¬ìš©ëŸ‰ ì¸¡ì •

```rust
pub struct TokenUsageTracker {
    total_input_tokens: u32,
    total_output_tokens: u32,
    api_calls_count: u32,
}

impl TokenUsageTracker {
    pub fn track(&mut self, usage: &Usage) {
        self.total_input_tokens += usage.input_tokens;
        self.total_output_tokens += usage.output_tokens;
        self.api_calls_count += 1;
    }

    pub fn calculate_cost(&self) -> f64 {
        // Claude 3.5 Sonnet ê°€ê²© (2024ë…„ ê¸°ì¤€)
        // Input: $3 / 1M tokens
        // Output: $15 / 1M tokens
        let input_cost = (self.total_input_tokens as f64 / 1_000_000.0) * 3.0;
        let output_cost = (self.total_output_tokens as f64 / 1_000_000.0) * 15.0;
        input_cost + output_cost
    }

    pub fn monthly_estimate(&self, days_active: u32) -> f64 {
        let daily_cost = self.calculate_cost() / days_active as f64;
        daily_cost * 30.0
    }
}
```

#### 5.4.2 ì˜ˆìƒ ë¹„ìš© ê³„ì‚°

**ê°€ì •**:
- ì¼ì¼ ì¬ê³  í’ˆëª© ìˆ˜: 100ê°œ
- AI ë¶„ì„ ë¹ˆë„:
  - ì•ˆì „ì¬ê³  ë¶„ì„: ì£¼ 1íšŒ (í’ˆëª©ë‹¹)
  - ë¹„ìš© ì ˆê° ë¶„ì„: ì›” 1íšŒ (ì „ì²´)
  - ì¼ì¼ ë¦¬í¬íŠ¸: ë§¤ì¼ 1íšŒ
  - ëŒ€ì‹œë³´ë“œ ì¸ì‚¬ì´íŠ¸: ì¼ 5íšŒ

**ì˜ˆìƒ í† í° ì‚¬ìš©ëŸ‰**:
```
ì•ˆì „ì¬ê³  ë¶„ì„:
  - Input: 500 tokens/ìš”ì²­ Ã— 100ê°œ í’ˆëª© Ã— 4íšŒ/ì›” = 200,000 tokens/ì›”
  - Output: 300 tokens/ìš”ì²­ Ã— 100ê°œ í’ˆëª© Ã— 4íšŒ/ì›” = 120,000 tokens/ì›”

ë¹„ìš© ì ˆê° ë¶„ì„:
  - Input: 2,000 tokens/ìš”ì²­ Ã— 1íšŒ/ì›” = 2,000 tokens/ì›”
  - Output: 1,000 tokens/ìš”ì²­ Ã— 1íšŒ/ì›” = 1,000 tokens/ì›”

ì¼ì¼ ë¦¬í¬íŠ¸:
  - Input: 1,500 tokens/ìš”ì²­ Ã— 30íšŒ/ì›” = 45,000 tokens/ì›”
  - Output: 800 tokens/ìš”ì²­ Ã— 30íšŒ/ì›” = 24,000 tokens/ì›”

ëŒ€ì‹œë³´ë“œ ì¸ì‚¬ì´íŠ¸:
  - Input: 800 tokens/ìš”ì²­ Ã— 150íšŒ/ì›” = 120,000 tokens/ì›”
  - Output: 500 tokens/ìš”ì²­ Ã— 150íšŒ/ì›” = 75,000 tokens/ì›”

ì´ í† í° ì‚¬ìš©ëŸ‰/ì›”:
  - Input: 367,000 tokens
  - Output: 220,000 tokens

ì›”ê°„ ë¹„ìš©:
  - Input: (367,000 / 1,000,000) Ã— $3 = $1.10
  - Output: (220,000 / 1,000,000) Ã— $15 = $3.30
  - í•©ê³„: $4.40/ì›”

ìºì‹± íš¨ê³¼ (30% ì ˆê°):
  - ìµœì¢… ë¹„ìš©: $4.40 Ã— 0.70 = $3.08/ì›”
```

**ë¹„ìš© ì ˆê° ì „ëµ**:
1. **ìºì‹±**: 24ì‹œê°„ TTLë¡œ 30% ì ˆê°
2. **ë°°ì¹˜ ì²˜ë¦¬**: ì•ˆì „ì¬ê³  ë¶„ì„ì„ ë°°ì¹˜ë¡œ ì²˜ë¦¬í•˜ì—¬ API í˜¸ì¶œ íšŸìˆ˜ ê°ì†Œ
3. **Prompt ìµœì í™”**: ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°, JSONë§Œ ìš”ì²­

---

### 5.5 ì—ëŸ¬ ì²˜ë¦¬ ë° Fallback

#### 5.5.1 ì¬ì‹œë„ ë¡œì§

```rust
pub async fn call_claude_with_retry(
    api: &ClaudeAPI,
    system_prompt: &str,
    user_message: &str,
    max_retries: u32,
) -> Result<ClaudeResponse, String> {
    let mut attempts = 0;

    loop {
        match api.send_message(system_prompt, user_message, 2000).await {
            Ok(response) => return Ok(response),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                log::warn!("Claude API call failed (attempt {}/{}): {}", attempts, max_retries, e);

                // ì§€ìˆ˜ ë°±ì˜¤í”„ (1s, 2s, 4s, ...)
                let delay = Duration::from_secs(2u64.pow(attempts - 1));
                tokio::time::sleep(delay).await;
            }
            Err(e) => {
                return Err(format!("Claude API call failed after {} retries: {}", max_retries, e));
            }
        }
    }
}
```

#### 5.5.2 Fallback ì „ëµ

```rust
pub async fn analyze_with_fallback(
    api: &ClaudeAPI,
    cache: &mut AIResponseCache,
    item_data: &ItemData,
) -> Result<SafetyStockRecommendation, String> {
    let cache_key = generate_cache_key("safety_stock", item_data);

    // 1. ìºì‹œ í™•ì¸
    if let Some(cached) = cache.get(&cache_key) {
        return parse_recommendation(&cached);
    }

    // 2. AI í˜¸ì¶œ ì‹œë„
    let (system, user) = generate_safety_stock_prompt(item_data);
    match call_claude_with_retry(api, &system, &user, 3).await {
        Ok(response) => {
            let content = &response.content[0].text;
            cache.set(cache_key, content.clone());
            parse_recommendation(content)
        }
        Err(e) => {
            log::error!("AI analysis failed, using statistical fallback: {}", e);

            // 3. Fallback: í†µê³„ì  ê³„ì‚°
            Ok(calculate_statistical_safety_stock(item_data))
        }
    }
}

fn calculate_statistical_safety_stock(data: &ItemData) -> SafetyStockRecommendation {
    let z_score = 1.65; // 95% ì„œë¹„ìŠ¤ ìˆ˜ì¤€
    let safety_stock = z_score * data.std_dev * (data.lead_time_days as f64).sqrt();

    SafetyStockRecommendation {
        recommended_safety_stock: safety_stock,
        reasoning: "AI ë¶„ì„ ì‹¤íŒ¨ë¡œ í†µê³„ì  ë°©ë²• ì‚¬ìš©".to_string(),
        risk_factors: vec!["AI ë¶„ì„ ë¯¸ì‚¬ìš©".to_string()],
        confidence: 0.7,
    }
}
```

---

### 5.6 ì„±ëŠ¥ ì¸¡ì • ë° ëª¨ë‹ˆí„°ë§

#### 5.6.1 AI í˜¸ì¶œ ë©”íŠ¸ë¦­

```rust
#[derive(Default)]
pub struct AIMetrics {
    pub total_calls: u32,
    pub cache_hits: u32,
    pub cache_misses: u32,
    pub avg_response_time_ms: f64,
    pub total_cost_usd: f64,
}

impl AIMetrics {
    pub fn cache_hit_rate(&self) -> f64 {
        if self.total_calls == 0 {
            return 0.0;
        }
        (self.cache_hits as f64 / self.total_calls as f64) * 100.0
    }

    pub fn report(&self) -> String {
        format!(r#"
AI ì„±ëŠ¥ ë¦¬í¬íŠ¸:
- ì´ í˜¸ì¶œ íšŸìˆ˜: {}íšŒ
- ìºì‹œ ì ì¤‘ë¥ : {:.1}% ({}/{}íšŒ)
- í‰ê·  ì‘ë‹µ ì‹œê°„: {:.0}ms
- ì´ ë¹„ìš©: ${:.2}
        "#,
            self.total_calls,
            self.cache_hit_rate(),
            self.cache_hits,
            self.total_calls,
            self.avg_response_time_ms,
            self.total_cost_usd,
        )
    }
}
```

---

**(ì„¹ì…˜ 5 ì™„ë£Œ! ì•½ 300ì¤„ ì¶”ê°€ âœ…)**

---

## ì„¹ì…˜ 6: ë‹¨ê³„ë³„ ê°œë°œ ì¼ì • (Phase 11-15)

### 6.1 Phase 11: ìœ í†µê¸°í•œ ê´€ë¦¬ ëª¨ë“ˆ êµ¬í˜„ (3ì£¼)

#### ì£¼ì°¨ë³„ Task ë¶„í•´

**1ì£¼ì°¨: ê¸°ë³¸ CRUD + ì•Œë¦¼ ë¡œì§**
- [ ] Day 1-2: `inventory_lots` í…Œì´ë¸” ë° Entity êµ¬í˜„ (16h)
  - SeaORM ëª¨ë¸ ìƒì„±
  - CRUD API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
  - ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±
- [ ] Day 3-4: ìœ í†µê¸°í•œ ì•Œë¦¼ ë¡œì§ êµ¬í˜„ (16h)
  - `expiration_tracking` í…Œì´ë¸” ì—°ë™
  - ì•Œë¦¼ ìƒíƒœ ìë™ ì—…ë°ì´íŠ¸ (normal/warning/critical/expired)
  - ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • (ë§¤ì¼ ì˜¤ì „ 9ì‹œ ì‹¤í–‰)
- [ ] Day 5: UI ì»´í¬ë„ŒíŠ¸ ê°œë°œ (8h)
  - ìœ í†µê¸°í•œ ëª©ë¡ í…Œì´ë¸” (React)
  - ìƒíƒœë³„ ìƒ‰ìƒ êµ¬ë¶„ (ì´ˆë¡/ë…¸ë‘/ë¹¨ê°•/íšŒìƒ‰)
  - í•„í„°ë§ ê¸°ëŠ¥ (7ì¼ ì´ë‚´/ë§Œë£Œë¨/ì „ì²´)

**2ì£¼ì°¨: FIFO ê²€ì¦ + AI ë¶„ì„**
- [ ] Day 6-7: FIFO ì¤€ìˆ˜ìœ¨ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ (16h)
  - ì¶œê³  ìˆœì„œ ê²€ì¦ ë¡œì§
  - ìœ„ë°˜ ì‚¬ë¡€ ìë™ ê°ì§€
  - ê²½ê³  ë©”ì‹œì§€ ìƒì„±
- [ ] Day 8-9: AI ê¸°ë°˜ íê¸° ì˜ˆì¸¡ (16h)
  - Claude API í†µí•©
  - Prompt ì„¤ê³„ (ê³¼ê±° ë°ì´í„° ê¸°ë°˜ ì˜ˆì¸¡)
  - ì‘ë‹µ íŒŒì‹± ë° ìºì‹±
- [ ] Day 10: ë¦¬í¬íŠ¸ ìƒì„± ê¸°ëŠ¥ (8h)
  - ì£¼ê°„ ìœ í†µê¸°í•œ ë¦¬í¬íŠ¸ í…œí”Œë¦¿
  - PDF ë‚´ë³´ë‚´ê¸° (tauri-plugin-pdf)

**3ì£¼ì°¨: í…ŒìŠ¤íŠ¸ + ë°°í¬**
- [ ] Day 11-12: í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„± (16h)
  - E2E ì‹œë‚˜ë¦¬ì˜¤ (ìœ í†µê¸°í•œ ë“±ë¡ â†’ ì•Œë¦¼ â†’ ì²˜ë¦¬)
  - ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (1000ê°œ ë¡œíŠ¸ ì²˜ë¦¬ < 1ì´ˆ)
- [ ] Day 13-14: ë²„ê·¸ ìˆ˜ì • ë° ìµœì í™” (16h)
  - ì½”ë“œ ë¦¬ë·° ë°˜ì˜
  - ì¿¼ë¦¬ ì„±ëŠ¥ ê°œì„ 
- [ ] Day 15: ë°°í¬ ì¤€ë¹„ ë° ë¬¸ì„œí™” (8h)
  - ì‚¬ìš©ì ë§¤ë‰´ì–¼ ì‘ì„±
  - CHANGELOG ì—…ë°ì´íŠ¸

**Phase 11 ì´ ì†Œìš” ì‹œê°„**: 120ì‹œê°„ (3ì£¼ Ã— 40h/ì£¼)

---

### 6.2 Phase 12: ì•ˆì „ì¬ê³  ëª¨ë“ˆ êµ¬í˜„ (2ì£¼)

#### ì£¼ì°¨ë³„ Task ë¶„í•´

**1ì£¼ì°¨: ì•Œê³ ë¦¬ì¦˜ + ê³„ì‚° ë¡œì§**
- [ ] Day 1-2: `safety_stock_settings` í…Œì´ë¸” êµ¬í˜„ (16h)
  - SeaORM ëª¨ë¸ ìƒì„±
  - CRUD API ì—”ë“œí¬ì¸íŠ¸
- [ ] Day 2-3: í†µê³„ì  ì•ˆì „ì¬ê³  ê³„ì‚° êµ¬í˜„ (16h)
  - Z-score ê¸°ë°˜ ê³µì‹ (SS = Z Ã— Ïƒ_L Ã— âˆšL)
  - ì¼ì¼ ì‚¬ìš©ëŸ‰ í†µê³„ ê³„ì‚° (í‰ê· , í‘œì¤€í¸ì°¨)
  - ROP ê³„ì‚° (Reorder Point)
- [ ] Day 4-5: AI ê¸°ë°˜ ì¶”ì²œ ì‹œìŠ¤í…œ (16h)
  - Claude API í˜¸ì¶œ
  - Prompt ì„¤ê³„ (ê³¼ê±° ì¬ê³  ë¶€ì¡± ë°ì´í„° í™œìš©)
  - Few-shot í•™ìŠµ ë°ì´í„° êµ¬ì„±

**2ì£¼ì°¨: UI + ì•Œë¦¼ ì‹œìŠ¤í…œ**
- [ ] Day 6-7: ì•ˆì „ì¬ê³  ì„¤ì • UI (16h)
  - í’ˆëª©ë³„ ì„¤ì • í¼ (ì„œë¹„ìŠ¤ ìˆ˜ì¤€, ë¦¬ë“œíƒ€ì„ ë“±)
  - ìë™ ê³„ì‚° ë²„íŠ¼
  - AI ì¶”ì²œ í‘œì‹œ
- [ ] Day 8-9: ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„ (16h)
  - ì•ˆì „ì¬ê³  ë¯¸ë‹¬ì‹œ ìë™ ì•Œë¦¼
  - ë°œì£¼ ì œì•ˆ ìƒì„±
- [ ] Day 10: í…ŒìŠ¤íŠ¸ + ë°°í¬ (8h)
  - ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸
  - ë¬¸ì„œí™”

**Phase 12 ì´ ì†Œìš” ì‹œê°„**: 80ì‹œê°„ (2ì£¼ Ã— 40h/ì£¼)

---

### 6.3 Phase 13: MRP + ìë™ë°œì£¼ì„œ ëª¨ë“ˆ êµ¬í˜„ (3ì£¼)

#### ì£¼ì°¨ë³„ Task ë¶„í•´

**1ì£¼ì°¨: MRP ê³„ì‚° ì—”ì§„**
- [ ] Day 1-2: BOM (ìì¬ ëª…ì„¸ì„œ) ë°ì´í„° ëª¨ë¸ êµ¬í˜„ (16h)
  - `bom` í…Œì´ë¸” ì„¤ê³„ ë° êµ¬í˜„
  - ë¶€ëª¨-ìì‹ ê´€ê³„ ê´€ë¦¬
- [ ] Day 3-4: MRP ê³„ì‚° ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ (16h)
  - í•„ìš” ìˆ˜ëŸ‰ ê³„ì‚° (Gross â†’ Net Requirements)
  - ë°œì£¼ ì¼ì • ìƒì„± (ë¦¬ë“œíƒ€ì„ ê³ ë ¤)
- [ ] Day 5: ë¦¬í¬íŠ¸ ìƒì„± (8h)
  - MRP ì‹¤í–‰ ê²°ê³¼ í…Œì´ë¸”
  - ì‹œê°í™” (íƒ€ì„ë¼ì¸)

**2ì£¼ì°¨: ìë™ë°œì£¼ì„œ ìƒì„±**
- [ ] Day 6-7: ë°œì£¼ì„œ ë°ì´í„° ëª¨ë¸ êµ¬í˜„ (16h)
  - `purchase_orders` í…Œì´ë¸”
  - ë°œì£¼ ìƒíƒœ ê´€ë¦¬ (ëŒ€ê¸°/ìŠ¹ì¸/ë°œì£¼/ì™„ë£Œ)
- [ ] Day 8-9: ìë™ ë°œì£¼ì„œ ìƒì„± ë¡œì§ (16h)
  - ROP ê¸°ë°˜ ìë™ íŠ¸ë¦¬ê±°
  - EOQ ê³„ì‚° (ìµœì  ë°œì£¼ëŸ‰)
  - ê³µê¸‰ì—…ì²´ ì„ íƒ ë¡œì§ (ê°€ê²© ë¹„êµ)
- [ ] Day 10: AI ìŠ¹ì¸ ì¶”ì²œ ì‹œìŠ¤í…œ (8h)
  - Claude API í™œìš©
  - ë°œì£¼ì„œ ê²€í†  ë° ìœ„í—˜ ìš”ì†Œ ë¶„ì„

**3ì£¼ì°¨: UI + í…ŒìŠ¤íŠ¸**
- [ ] Day 11-12: ë°œì£¼ì„œ ê´€ë¦¬ UI (16h)
  - ë°œì£¼ì„œ ëª©ë¡ ë° ìƒì„¸
  - ìŠ¹ì¸/ê±°ë¶€ ë²„íŠ¼
  - PDF ë‚´ë³´ë‚´ê¸°
- [ ] Day 13-14: í†µí•© í…ŒìŠ¤íŠ¸ (16h)
  - MRP â†’ ë°œì£¼ì„œ ìë™ ìƒì„± E2E ì‹œë‚˜ë¦¬ì˜¤
  - ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] Day 15: ë°°í¬ ë° ë¬¸ì„œí™” (8h)

**Phase 13 ì´ ì†Œìš” ì‹œê°„**: 120ì‹œê°„ (3ì£¼ Ã— 40h/ì£¼)

---

### 6.4 Phase 14: ë¹„ìš©ê´€ë¦¬ + ì¼ì¼ ë¦¬í¬íŠ¸ ëª¨ë“ˆ êµ¬í˜„ (2ì£¼)

#### ì£¼ì°¨ë³„ Task ë¶„í•´

**1ì£¼ì°¨: ë¹„ìš©ê´€ë¦¬ ëª¨ë“ˆ**
- [ ] Day 1-2: ë¹„ìš© ë¶„ì„ ë°ì´í„° ëª¨ë¸ êµ¬í˜„ (16h)
  - `cost_analysis` í…Œì´ë¸”
  - í†µê³„ ê³„ì‚° í•¨ìˆ˜ (í‰ê· , í‘œì¤€í¸ì°¨, ì¶”ì„¸)
- [ ] Day 3-4: ê³µê¸‰ì—…ì²´ ê°€ê²© ë¹„êµ ë¡œì§ (16h)
  - `supplier_prices` í…Œì´ë¸” ì—°ë™
  - ìµœì €ê°€ ê³µê¸‰ì—…ì²´ ìë™ ì„ íƒ
  - ì ˆê° ê¸°íšŒ ë°œê²¬ ì•Œê³ ë¦¬ì¦˜
- [ ] Day 5: AI ê¸°ë°˜ ë¹„ìš© ì˜ˆì¸¡ (8h)
  - Claude API í™œìš©
  - ë‹¤ìŒ ë‹¬ ë¹„ìš© ì˜ˆì¸¡
  - ì ˆê° ì•¡ì…˜ í”Œëœ ìƒì„±

**2ì£¼ì°¨: ì¼ì¼ ë¦¬í¬íŠ¸ ëª¨ë“ˆ**
- [ ] Day 6-7: ë¦¬í¬íŠ¸ ìƒì„± ì—”ì§„ (16h)
  - ì¼ì¼ í†µê³„ ì§‘ê³„ (ì…ê³ /ì¶œê³ /ì¬ê³ )
  - ì´ìƒ ì§•í›„ ê°ì§€ (IQR ë°©ë²•)
- [ ] Day 8: AI ìš”ì•½ ë° ì¸ì‚¬ì´íŠ¸ ìƒì„± (8h)
  - Claude API í™œìš©
  - ê²½ì˜ì§„ìš© ìš”ì•½ (2-3ë¬¸ì¥)
- [ ] Day 9: ì´ë©”ì¼ ë°œì†¡ ì‹œìŠ¤í…œ (8h)
  - SMTP ì—°ë™
  - ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • (ë§¤ì¼ ì˜¤ì „ 9ì‹œ)
- [ ] Day 10: í…ŒìŠ¤íŠ¸ + ë°°í¬ (8h)
  - ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸
  - ë¬¸ì„œí™”

**Phase 14 ì´ ì†Œìš” ì‹œê°„**: 80ì‹œê°„ (2ì£¼ Ã— 40h/ì£¼)

---

### 6.5 Phase 15: ëŒ€ì‹œë³´ë“œ ëª¨ë“ˆ êµ¬í˜„ (2ì£¼)

#### ì£¼ì°¨ë³„ Task ë¶„í•´

**1ì£¼ì°¨: ëŒ€ì‹œë³´ë“œ ë°±ì—”ë“œ + ì‹¤ì‹œê°„ ë°ì´í„°**
- [ ] Day 1-2: ëŒ€ì‹œë³´ë“œ ë°ì´í„° ì§‘ê³„ ë¡œì§ (16h)
  - KPI ê³„ì‚° (ì¬ê³  íšŒì „ìœ¨, ì¬ê³  ì¼ìˆ˜, ê°€ë™ë¥ )
  - ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
- [ ] Day 3-4: WebSocket ì„œë²„ êµ¬í˜„ (16h)
  - Tauri WebSocket í”ŒëŸ¬ê·¸ì¸ í™œìš©
  - ì‹¤ì‹œê°„ ë°ì´í„° í‘¸ì‹œ
- [ ] Day 5: ì•Œë¦¼ ì‹œìŠ¤í…œ í†µí•© (8h)
  - ì„ê³„ê°’ ì´ˆê³¼ì‹œ ìë™ ì•Œë¦¼
  - ë¸Œë¼ìš°ì € ì•Œë¦¼ (Notification API)

**2ì£¼ì°¨: ëŒ€ì‹œë³´ë“œ í”„ë¡ íŠ¸ì—”ë“œ**
- [ ] Day 6-7: ì°¨íŠ¸ ì»´í¬ë„ŒíŠ¸ êµ¬í˜„ (16h)
  - MetricCard (KPI ì¹´ë“œ)
  - LineChart (ì¶”ì„¸)
  - BarChart (ë¹„êµ)
  - GaugeChart (ê²Œì´ì§€)
- [ ] Day 8-9: ë ˆì´ì•„ì›ƒ ë° ë°˜ì‘í˜• ë””ìì¸ (16h)
  - Grid ë ˆì´ì•„ì›ƒ
  - ëª¨ë°”ì¼ ëŒ€ì‘
- [ ] Day 10: í…ŒìŠ¤íŠ¸ + ë°°í¬ (8h)
  - E2E í…ŒìŠ¤íŠ¸
  - ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (ì°¨íŠ¸ ë Œë”ë§ < 500ms)
  - ë¬¸ì„œí™”

**Phase 15 ì´ ì†Œìš” ì‹œê°„**: 80ì‹œê°„ (2ì£¼ Ã— 40h/ì£¼)

---

### 6.6 ì „ì²´ ì¼ì • ìš”ì•½

| Phase | ëª¨ë“ˆ | ì†Œìš” ì‹œê°„ | ê¸°ê°„ | ëˆ„ì  ì§„í–‰ë¥  |
|-------|------|----------|------|------------|
| **Phase 11** | ìœ í†µê¸°í•œ ê´€ë¦¬ | 120h | 3ì£¼ | 25% |
| **Phase 12** | ì•ˆì „ì¬ê³  | 80h | 2ì£¼ | 42% |
| **Phase 13** | MRP + ìë™ë°œì£¼ì„œ | 120h | 3ì£¼ | 67% |
| **Phase 14** | ë¹„ìš©ê´€ë¦¬ + ì¼ì¼ ë¦¬í¬íŠ¸ | 80h | 2ì£¼ | 83% |
| **Phase 15** | ëŒ€ì‹œë³´ë“œ | 80h | 2ì£¼ | 100% |
| **ì´ê³„** | 7ê°œ ëª¨ë“ˆ | **480h** | **12ì£¼** | - |

**ì¸ë ¥ ê³„íš**:
- 1ëª… ê°œë°œì ê¸°ì¤€: 12ì£¼ (3ê°œì›”)
- ì£¼ 40ì‹œê°„ ê·¼ë¬´ ê°€ì •

**ë§ˆì¼ìŠ¤í†¤**:
- Week 3: Phase 11 ì™„ë£Œ (ìœ í†µê¸°í•œ ê´€ë¦¬ ì¶œì‹œ)
- Week 5: Phase 12 ì™„ë£Œ (ì•ˆì „ì¬ê³  ì¶”ê°€)
- Week 8: Phase 13 ì™„ë£Œ (MRP + ìë™ë°œì£¼ì„œ ì¶œì‹œ)
- Week 10: Phase 14 ì™„ë£Œ (ë¹„ìš©ê´€ë¦¬ + ë¦¬í¬íŠ¸ ì¶”ê°€)
- Week 12: Phase 15 ì™„ë£Œ (ì „ì²´ ëª¨ë“ˆ ì™„ì„±! ğŸ‰)

---

### 6.7 ë¦¬ìŠ¤í¬ ì™„í™” ì „ëµ

#### 6.7.1 ì¼ì • ì§€ì—° ëŒ€ë¹„

**ì™„ì¶© ì‹œê°„ (Buffer)**:
- ê° Phase ì¢…ë£Œ í›„ 2-3ì¼ ì—¬ìœ  í™•ë³´
- ì˜ˆìƒì¹˜ ëª»í•œ ë²„ê·¸ ìˆ˜ì • ì‹œê°„

**ìš°ì„ ìˆœìœ„ ì¡°ì •**:
- í•µì‹¬ ê¸°ëŠ¥ ìš°ì„  êµ¬í˜„ (ìœ í†µê¸°í•œ ê´€ë¦¬, ì•ˆì „ì¬ê³ )
- ë¶€ê°€ ê¸°ëŠ¥ì€ Phase 16 ì´í›„ë¡œ ì—°ê¸° ê°€ëŠ¥

#### 6.7.2 ê¸°ìˆ  ë¦¬ìŠ¤í¬ ëŒ€ë¹„

**AI API ì¥ì•  ëŒ€ë¹„**:
- Fallback ë¡œì§ êµ¬í˜„ (í†µê³„ì  ê³„ì‚°)
- ìºì‹±ìœ¼ë¡œ ì˜ì¡´ë„ ê°ì†Œ

**ì„±ëŠ¥ ì´ìŠˆ ëŒ€ë¹„**:
- ì´ˆê¸°ë¶€í„° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ë³‘í–‰
- ë³‘ëª© ì§€ì  ì¡°ê¸° ë°œê²¬

---

**(ì„¹ì…˜ 6 ì™„ë£Œ! ì•½ 300ì¤„ ì¶”ê°€ âœ…)**

---

## ì„¹ì…˜ 7: ìœ„í—˜ ê´€ë¦¬ ë° ëŒ€ì‘ ì „ëµ

### 7.1 ê¸°ìˆ  ë¦¬ìŠ¤í¬

#### 7.1.1 AI API ì˜ì¡´ì„± ë¦¬ìŠ¤í¬

**ìœ„í—˜**: Claude API ì¥ì•  ë˜ëŠ” ì‘ë‹µ ì§€ì—°ìœ¼ë¡œ í•µì‹¬ ê¸°ëŠ¥ ì‚¬ìš© ë¶ˆê°€

**ë°œìƒ í™•ë¥ **: ì¤‘ (5%)
**ì˜í–¥ë„**: ë†’ìŒ
**ì‹¬ê°ë„**: ğŸ”´ Critical

**ì™„í™” ì „ëµ**:
1. **Fallback ë¡œì§ êµ¬í˜„**
   ```rust
   // AI ì‹¤íŒ¨ì‹œ í†µê³„ì  ê³„ì‚°ìœ¼ë¡œ ì „í™˜
   match call_claude_api().await {
       Ok(result) => result,
       Err(_) => calculate_statistical_fallback(data),
   }
   ```

2. **ì‘ë‹µ ìºì‹± (24ì‹œê°„ TTL)**
   - ìºì‹œ ì ì¤‘ë¥  ëª©í‘œ: 30%
   - API ì˜ì¡´ë„ 70%ë¡œ ê°ì†Œ

3. **íƒ€ì„ì•„ì›ƒ ì„¤ì •**
   - API í˜¸ì¶œ íƒ€ì„ì•„ì›ƒ: 10ì´ˆ
   - ì´ˆê³¼ì‹œ ì¦‰ì‹œ Fallback

4. **ìƒíƒœ ëª¨ë‹ˆí„°ë§**
   - API ì„±ê³µë¥  ì‹¤ì‹œê°„ ì¶”ì 
   - 80% ë¯¸ë§Œì‹œ ê´€ë¦¬ì ì•Œë¦¼

**ëª¨ë‹ˆí„°ë§ ì§€í‘œ**:
- API ì‘ë‹µ ì‹œê°„ (ëª©í‘œ: < 2ì´ˆ)
- API ì„±ê³µë¥  (ëª©í‘œ: > 95%)
- ìºì‹œ ì ì¤‘ë¥  (ëª©í‘œ: > 30%)

---

#### 7.1.2 SQLite ì„±ëŠ¥ ë¦¬ìŠ¤í¬

**ìœ„í—˜**: ì¬ê³  í’ˆëª© 1000ê°œ ì´ìƒì‹œ ì¿¼ë¦¬ ì„±ëŠ¥ ì €í•˜

**ë°œìƒ í™•ë¥ **: ì¤‘ (30%)
**ì˜í–¥ë„**: ì¤‘
**ì‹¬ê°ë„**: ğŸŸ¡ Medium

**ì™„í™” ì „ëµ**:
1. **ì¸ë±ìŠ¤ ìµœì í™”**
   ```sql
   -- ë³µí•© ì¸ë±ìŠ¤ë¡œ ì¡°íšŒ ì„±ëŠ¥ ê°œì„ 
   CREATE INDEX idx_lot_item_exp
   ON inventory_lots(item_id, expiration_date);
   ```

2. **í˜ì´ì§€ë„¤ì´ì…˜ êµ¬í˜„**
   - í•œ ë²ˆì— 50ê°œ í’ˆëª©ë§Œ ë¡œë“œ
   - ë¬´í•œ ìŠ¤í¬ë¡¤ ì ìš©

3. **ë°±ê·¸ë¼ìš´ë“œ ì§‘ê³„**
   - í†µê³„ ë°ì´í„° ì‚¬ì „ ê³„ì‚° (ë§¤ì¼ ì˜¤ì „ 1ì‹œ)
   - ì‹¤ì‹œê°„ ê³„ì‚° ë¶€ë‹´ ê°ì†Œ

4. **ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬**
   - 1000ê°œ í’ˆëª© ì¡°íšŒ: < 100ms
   - 10000ê°œ ê±°ë˜ ë‚´ì—­ ì§‘ê³„: < 500ms

**ëŒ€ì‘ ê³„íš**:
- Phase 1: SQLite ìµœì í™” (ì¸ë±ìŠ¤, ì¿¼ë¦¬ íŠœë‹)
- Phase 2: í•„ìš”ì‹œ PostgreSQL ë§ˆì´ê·¸ë ˆì´ì…˜ ê³ ë ¤

---

#### 7.1.3 Tauri ì—…ê·¸ë ˆì´ë“œ ë¦¬ìŠ¤í¬

**ìœ„í—˜**: Tauri 2.0 ì „í™˜ì‹œ í˜¸í™˜ì„± ë¬¸ì œ

**ë°œìƒ í™•ë¥ **: ë‚®ìŒ (10%)
**ì˜í–¥ë„**: ì¤‘
**ì‹¬ê°ë„**: ğŸŸ¡ Medium

**ì™„í™” ì „ëµ**:
1. **í˜„ì¬ ë²„ì „ ê³ ì •**
   - Tauri 1.5.4 ìœ ì§€
   - ì•ˆì •ì„± ìš°ì„ 

2. **ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš**
   - Tauri 2.0 ì•ˆì •í™” í›„ ê²€í†  (2025ë…„ Q3)
   - Breaking Changes ëª©ë¡ ì‚¬ì „ í™•ì¸

3. **í…ŒìŠ¤íŠ¸ ìë™í™”**
   - E2E í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ > 80%
   - ì—…ê·¸ë ˆì´ë“œ í›„ íšŒê·€ í…ŒìŠ¤íŠ¸

---

### 7.2 ì¼ì • ë¦¬ìŠ¤í¬

#### 7.2.1 ê°œë°œ ì¼ì • ì§€ì—° ë¦¬ìŠ¤í¬

**ìœ„í—˜**: ì˜ˆìƒë³´ë‹¤ êµ¬í˜„ ë³µì¡ë„ ë†’ì•„ ì¼ì • ì§€ì—°

**ë°œìƒ í™•ë¥ **: ë†’ìŒ (50%)
**ì˜í–¥ë„**: ì¤‘
**ì‹¬ê°ë„**: ğŸŸ¡ Medium

**ì™„í™” ì „ëµ**:
1. **ì™„ì¶© ì‹œê°„ í™•ë³´**
   - ê° Phase ì¢…ë£Œ í›„ 2-3ì¼ ì—¬ìœ 
   - ì´ 12ì£¼ ê³„íšì— 2ì£¼ ì¶”ê°€ (ì´ 14ì£¼)

2. **ìš°ì„ ìˆœìœ„ ì¡°ì •**
   - í•µì‹¬ ê¸°ëŠ¥ ìš°ì„  (ìœ í†µê¸°í•œ, ì•ˆì „ì¬ê³ )
   - ë¶€ê°€ ê¸°ëŠ¥ Phase 16 ì´í›„ ì—°ê¸°

3. **ì£¼ê°„ ì§„ì²™ë„ ì ê²€**
   - ë§¤ì£¼ ê¸ˆìš”ì¼ ì§„í–‰ë¥  ê²€í† 
   - 20% ì´ìƒ ì§€ì—°ì‹œ ìš°ì„ ìˆœìœ„ ì¬ì¡°ì •

4. **ë‹¨ê³„ë³„ ì¶œì‹œ (Staged Release)**
   | Phase | ì¶œì‹œ ë²„ì „ | ê¸°ëŠ¥ |
   |-------|----------|------|
   | Phase 11 | v0.11.0 | ìœ í†µê¸°í•œ ê´€ë¦¬ |
   | Phase 12 | v0.12.0 | + ì•ˆì „ì¬ê³  |
   | Phase 13 | v0.13.0 | + MRP + ìë™ë°œì£¼ì„œ |
   | Phase 14 | v0.14.0 | + ë¹„ìš©ê´€ë¦¬ + ë¦¬í¬íŠ¸ |
   | Phase 15 | v0.15.0 | + ëŒ€ì‹œë³´ë“œ (ì™„ì„±!) |

---

#### 7.2.2 ë¦¬ì†ŒìŠ¤ ë¶€ì¡± ë¦¬ìŠ¤í¬

**ìœ„í—˜**: 1ëª… ê°œë°œìë¡œ 12ì£¼ ì¼ì • ë‹¬ì„± ì–´ë ¤ì›€

**ë°œìƒ í™•ë¥ **: ì¤‘ (30%)
**ì˜í–¥ë„**: ë†’ìŒ
**ì‹¬ê°ë„**: ğŸ”´ Critical

**ì™„í™” ì „ëµ**:
1. **AI ì—ì´ì „íŠ¸ í™œìš©**
   - Claude Codeë¡œ ì½”ë“œ ìƒì„± ìë™í™”
   - ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ 50% ì ˆê°

2. **ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¬ì‚¬ìš©**
   - SeaORM, Tauri í”ŒëŸ¬ê·¸ì¸ ì ê·¹ í™œìš©
   - ì§ì ‘ êµ¬í˜„ ìµœì†Œí™”

3. **ì™¸ì£¼ ê²€í† **
   - UI ë””ìì¸ ë¶€ë¶„ ì™¸ì£¼ ê³ ë ¤
   - ê°œë°œìëŠ” ë°±ì—”ë“œ ë¡œì§ì— ì§‘ì¤‘

---

### 7.3 ë¹„ì¦ˆë‹ˆìŠ¤ ë¦¬ìŠ¤í¬

#### 7.3.1 ì‚¬ìš©ì ìˆ˜ìš© ë¦¬ìŠ¤í¬

**ìœ„í—˜**: AI ì¶”ì²œì„ ì‚¬ìš©ìê°€ ì‹ ë¢°í•˜ì§€ ì•ŠìŒ

**ë°œìƒ í™•ë¥ **: ì¤‘ (20%)
**ì˜í–¥ë„**: ë†’ìŒ
**ì‹¬ê°ë„**: ğŸ”´ Critical

**ì™„í™” ì „ëµ**:
1. **ì„¤ëª… ê°€ëŠ¥ì„± ê°•í™”**
   - AI ì¶”ì²œ ì´ìœ ë¥¼ ëª…í™•íˆ í‘œì‹œ
   - ì˜ˆ: "ê³¼ê±° 6ê°œì›” í‰ê·  ì‚¬ìš©ëŸ‰ 120ê°œ/ì¼, í‘œì¤€í¸ì°¨ 15ê°œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°"

2. **ìˆ˜ë™ ì¡°ì • ê¸°ëŠ¥**
   - AI ì¶”ì²œì„ ì°¸ê³ ìš©ìœ¼ë¡œë§Œ ì œê³µ
   - ì‚¬ìš©ìê°€ ìµœì¢… ê²°ì •

3. **ì‹ ë¢°ë„ ì ìˆ˜ í‘œì‹œ**
   - 0.0 ~ 1.0 ì ìˆ˜ë¡œ ì‹ ë¢°ë„ ì‹œê°í™”
   - 0.8 ì´ìƒë§Œ ê°•í•˜ê²Œ ì¶”ì²œ

4. **ë‹¨ê³„ì  ë„ì…**
   - Phase 1: AI ì¶”ì²œ ìˆ¨ê¹€ (í†µê³„ë§Œ)
   - Phase 2: AI ì¶”ì²œ í‘œì‹œ (ì„ íƒ ì‚¬í•­)
   - Phase 3: AI ì¶”ì²œ ê¸°ë³¸ê°’ (ìˆ˜ë™ ì¡°ì • ê°€ëŠ¥)

**ì‚¬ìš©ì í”¼ë“œë°± ìˆ˜ì§‘**:
- ë§¤ì£¼ ì‚¬ìš©ì ì¸í„°ë·° (5ëª…)
- AI ì¶”ì²œ ìˆ˜ìš©ë¥  ì¸¡ì • (ëª©í‘œ: > 60%)

---

#### 7.3.2 ë¹„ìš© ì´ˆê³¼ ë¦¬ìŠ¤í¬

**ìœ„í—˜**: AI API ë¹„ìš©ì´ ì˜ˆìƒë³´ë‹¤ ë†’ìŒ

**ë°œìƒ í™•ë¥ **: ë‚®ìŒ (10%)
**ì˜í–¥ë„**: ì¤‘
**ì‹¬ê°ë„**: ğŸŸ¢ Low

**ì™„í™” ì „ëµ**:
1. **ì›”ê°„ ë¹„ìš© ëª¨ë‹ˆí„°ë§**
   - ëª©í‘œ: $5/ì›” ì´í•˜
   - ì‹¤ì‹œê°„ ì‚¬ìš©ëŸ‰ ì¶”ì 

2. **ë¹„ìš© ìµœì í™”**
   - ìºì‹±ìœ¼ë¡œ 30% ì ˆê°
   - Prompt ìµœì í™” (ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°)

3. **ë¹„ìš© ì œí•œ ì„¤ì •**
   - $10/ì›” ì´ˆê³¼ì‹œ ìë™ ì•Œë¦¼
   - $20/ì›” ì´ˆê³¼ì‹œ AI ê¸°ëŠ¥ ì¼ì‹œ ì¤‘ë‹¨

4. **ëŒ€ì²´ ëª¨ë¸ ê²€í† **
   - Claude Haiku (ì €ê°€í˜•) í…ŒìŠ¤íŠ¸
   - GPT-4o-mini ë¹„êµ ë¶„ì„

---

### 7.4 ë¦¬ìŠ¤í¬ ë§¤íŠ¸ë¦­ìŠ¤

| ë¦¬ìŠ¤í¬ | í™•ë¥  | ì˜í–¥ë„ | ì‹¬ê°ë„ | ëŒ€ì‘ ì „ëµ |
|--------|------|--------|--------|----------|
| **AI API ì¥ì• ** | ì¤‘ (5%) | ë†’ìŒ | ğŸ”´ Critical | Fallback + ìºì‹± |
| **SQLite ì„±ëŠ¥ ì €í•˜** | ì¤‘ (30%) | ì¤‘ | ğŸŸ¡ Medium | ì¸ë±ìŠ¤ ìµœì í™” |
| **Tauri ì—…ê·¸ë ˆì´ë“œ** | ë‚®ìŒ (10%) | ì¤‘ | ğŸŸ¡ Medium | ë²„ì „ ê³ ì • |
| **ê°œë°œ ì¼ì • ì§€ì—°** | ë†’ìŒ (50%) | ì¤‘ | ğŸŸ¡ Medium | ì™„ì¶© ì‹œê°„ + ìš°ì„ ìˆœìœ„ |
| **ë¦¬ì†ŒìŠ¤ ë¶€ì¡±** | ì¤‘ (30%) | ë†’ìŒ | ğŸ”´ Critical | AI ìë™í™” + ì™¸ì£¼ |
| **ì‚¬ìš©ì ìˆ˜ìš© ê±°ë¶€** | ì¤‘ (20%) | ë†’ìŒ | ğŸ”´ Critical | ì„¤ëª… ê°€ëŠ¥ì„± + ìˆ˜ë™ ì¡°ì • |
| **ë¹„ìš© ì´ˆê³¼** | ë‚®ìŒ (10%) | ì¤‘ | ğŸŸ¢ Low | ë¹„ìš© ëª¨ë‹ˆí„°ë§ + ìµœì í™” |

**ë²”ë¡€**:
- ğŸ”´ Critical: ì¦‰ì‹œ ëŒ€ì‘ í•„ìš”
- ğŸŸ¡ Medium: ì£¼ê°„ ëª¨ë‹ˆí„°ë§
- ğŸŸ¢ Low: ì›”ê°„ ê²€í† 

---

### 7.5 ìœ„ê¸° ëŒ€ì‘ í”Œëœ

#### 7.5.1 AI API ì™„ì „ ì¥ì• ì‹œ

**ì‹œë‚˜ë¦¬ì˜¤**: Anthropic ì„œë¹„ìŠ¤ ì „ë©´ ì¤‘ë‹¨ (24ì‹œê°„ ì´ìƒ)

**ëŒ€ì‘ ì ˆì°¨**:
1. **ì¦‰ì‹œ ì¡°ì¹˜ (10ë¶„ ì´ë‚´)**
   - ëª¨ë“  AI ê¸°ëŠ¥ Fallback ëª¨ë“œ ì „í™˜
   - ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼: "AI ê¸°ëŠ¥ ì¼ì‹œ ì œí•œ, í†µê³„ì  ê³„ì‚°ìœ¼ë¡œ ìš´ì˜ ì¤‘"

2. **ë‹¨ê¸° ëŒ€ì‘ (24ì‹œê°„ ì´ë‚´)**
   - ëŒ€ì²´ API í…ŒìŠ¤íŠ¸ (OpenAI GPT-4)
   - ê¸°ì¡´ ìºì‹œ í™œìš© (24ì‹œê°„ TTL ì—°ì¥ â†’ 7ì¼)

3. **ì¥ê¸° ëŒ€ì‘ (1ì£¼ ì´ë‚´)**
   - Multi-cloud ì „ëµ êµ¬í˜„ (Claude + OpenAI ë³‘í–‰)
   - ë¡œì»¬ LLM ê²€í†  (Llama 3.1 8B)

---

#### 7.5.2 ì‹¬ê°í•œ ì„±ëŠ¥ ì €í•˜ì‹œ

**ì‹œë‚˜ë¦¬ì˜¤**: ì¬ê³  ì¡°íšŒê°€ 10ì´ˆ ì´ìƒ ì†Œìš”

**ëŒ€ì‘ ì ˆì°¨**:
1. **ì›ì¸ ë¶„ì„ (30ë¶„ ì´ë‚´)**
   - `EXPLAIN QUERY PLAN` ì‹¤í–‰
   - ë³‘ëª© ì¿¼ë¦¬ ì‹ë³„

2. **ê¸´ê¸‰ íŒ¨ì¹˜ (4ì‹œê°„ ì´ë‚´)**
   - ì¸ë±ìŠ¤ ì¶”ê°€
   - ì¿¼ë¦¬ ìµœì í™”

3. **ê·¼ë³¸ í•´ê²° (1ì£¼ ì´ë‚´)**
   - ì•„í‚¤í…ì²˜ ì¬ì„¤ê³„ ê²€í† 
   - PostgreSQL ë§ˆì´ê·¸ë ˆì´ì…˜ í‰ê°€

---

### 7.6 ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ í”Œëœ

#### 7.6.1 ë‚´ë¶€ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜

**ì¼ì¼ ì²´í¬ì¸** (ë§¤ì¼ ì˜¤ì „ 10ì‹œ, 15ë¶„):
- ì–´ì œ ì™„ë£Œí•œ ì‘ì—…
- ì˜¤ëŠ˜ ê³„íš
- ì°¨ë‹¨ ìš”ì†Œ (Blocker)

**ì£¼ê°„ ë¦¬ë·°** (ë§¤ì£¼ ê¸ˆìš”ì¼ ì˜¤í›„ 3ì‹œ, 1ì‹œê°„):
- ì£¼ê°„ ì§„í–‰ë¥  ê²€í† 
- ë¦¬ìŠ¤í¬ ì—…ë°ì´íŠ¸
- ë‹¤ìŒ ì£¼ ìš°ì„ ìˆœìœ„ í™•ì •

**ì›”ê°„ íšŒê³ ** (ë§¤ì›” ë§ˆì§€ë§‰ ê¸ˆìš”ì¼, 2ì‹œê°„):
- KPI ë‹¬ì„±ë„ í™•ì¸
- í”„ë¡œì„¸ìŠ¤ ê°œì„  ì‚¬í•­
- íŒ€ í”¼ë“œë°±

---

#### 7.6.2 ì‚¬ìš©ì ì»¤ë®¤ë‹ˆì¼€ì´ì…˜

**ë² íƒ€ ì¶œì‹œ ì „ (Phase 11 ì™„ë£Œì‹œ)**:
- 5ëª… ë² íƒ€ í…ŒìŠ¤í„° ëª¨ì§‘
- ì£¼ê°„ í”¼ë“œë°± ì„¸ì…˜ (30ë¶„)

**ì •ì‹ ì¶œì‹œ í›„**:
- ì›”ê°„ ì‚¬ìš©ì ì„œë² ì´
- ë¶„ê¸°ë³„ ë¡œë“œë§µ ê³µìœ 

---

### 7.7 ì„±ê³µ ì§€í‘œ (KPI)

#### 7.7.1 ê¸°ìˆ  ì§€í‘œ

| ì§€í‘œ | ëª©í‘œ | ì¸¡ì • ë°©ë²• |
|------|------|----------|
| **API ì‘ë‹µ ì‹œê°„** | < 2ì´ˆ | í‰ê·  ì‘ë‹µ ì‹œê°„ |
| **ì¿¼ë¦¬ ì„±ëŠ¥** | < 100ms | ë²¤ì¹˜ë§ˆí¬ |
| **ìºì‹œ ì ì¤‘ë¥ ** | > 30% | ìºì‹œ íˆíŠ¸/ì´ ìš”ì²­ |
| **ì—ëŸ¬ìœ¨** | < 1% | ì—ëŸ¬ ë¡œê·¸ ìˆ˜/ì´ ìš”ì²­ |
| **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€** | > 80% | Cargo Test |

#### 7.7.2 ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œ

| ì§€í‘œ | ëª©í‘œ | ì¸¡ì • ë°©ë²• |
|------|------|----------|
| **AI ì¶”ì²œ ìˆ˜ìš©ë¥ ** | > 60% | ìˆ˜ìš© íšŸìˆ˜/ì´ ì¶”ì²œ |
| **ì‚¬ìš©ì ë§Œì¡±ë„** | > 4.0/5.0 | NPS ì„¤ë¬¸ |
| **ì¼ì¼ í™œì„± ì‚¬ìš©ì** | > 20ëª… | ë¡œê·¸ì¸ ìˆ˜ |
| **ì¬ê³  ì •í™•ë„** | > 95% | ì‹¤ì‚¬ ëŒ€ë¹„ |
| **ì›ê°€ ì ˆê°ë¥ ** | > 5% | ë¹„ìš© ë¹„êµ |

---

### 7.8 ìµœì¢… ì²´í¬ë¦¬ìŠ¤íŠ¸

**Phase ì™„ë£Œ ì¡°ê±´**:
- [ ] ëª¨ë“  ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ í†µê³¼ (ë‹¨ìœ„ + í†µí•© + E2E)
- [ ] ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ í†µê³¼ (ëª©í‘œ ëŒ€ë¹„ > 90%)
- [ ] ì½”ë“œ ë¦¬ë·° ì™„ë£Œ (2ëª… ì´ìƒ ìŠ¹ì¸)
- [ ] ë¬¸ì„œí™” ì™„ë£Œ (API ë¬¸ì„œ + ì‚¬ìš©ì ë§¤ë‰´ì–¼)
- [ ] ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ ê²€ì¦
- [ ] ì‚¬ìš©ì í”¼ë“œë°± ìˆ˜ì§‘ (ë² íƒ€ 5ëª…)

**ì •ì‹ ì¶œì‹œ ì¡°ê±´** (Phase 15 ì™„ë£Œì‹œ):
- [ ] ì „ì²´ KPI ëª©í‘œ ë‹¬ì„±
- [ ] 30ì¼ ë¬´ì¥ì•  ìš´ì˜ (Uptime > 99.5%)
- [ ] ì‚¬ìš©ì ë§Œì¡±ë„ > 4.0/5.0
- [ ] ë³´ì•ˆ ì·¨ì•½ì  0ê±´
- [ ] ì„±ëŠ¥ ì €í•˜ ì´ìŠˆ 0ê±´

---

**(ì„¹ì…˜ 7 ì™„ë£Œ! ì•½ 200ì¤„ ì¶”ê°€ âœ…)**

---

## ğŸ‰ ì „ì²´ ë¬¸ì„œ ì™„ì„±!

**ìµœì¢… í†µê³„**:
- âœ… **ì„¹ì…˜ 1**: í”„ë¡œì íŠ¸ ê°œìš” ë° í†µí•© ë°©ì•ˆ (360ì¤„)
- âœ… **ì„¹ì…˜ 2**: ê¸°ìˆ  ìŠ¤íƒ ë° ì•„í‚¤í…ì²˜ (820ì¤„)
- âœ… **ì„¹ì…˜ 3**: 7ê°œ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„ (1,800ì¤„)
- âœ… **ì„¹ì…˜ 4**: ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„ (400ì¤„)
- âœ… **ì„¹ì…˜ 5**: AI ê¸°ëŠ¥ êµ¬í˜„ ì „ëµ (300ì¤„)
- âœ… **ì„¹ì…˜ 6**: ë‹¨ê³„ë³„ ê°œë°œ ì¼ì • Phase 11-15 (300ì¤„)
- âœ… **ì„¹ì…˜ 7**: ìœ„í—˜ ê´€ë¦¬ ë° ëŒ€ì‘ ì „ëµ (200ì¤„)

**ì´ ì•½ 4,180ì¤„ ì™„ì„±! (ëª©í‘œ 2,500-3,000ì¤„ ëŒ€ë¹„ 140% ë‹¬ì„±!)**

---

## ë‹¤ìŒ ë‹¨ê³„

1. **ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥**: Phase 11 (ìœ í†µê¸°í•œ ê´€ë¦¬ ëª¨ë“ˆ) ê°œë°œ ì°©ìˆ˜
2. **ë¬¸ì„œ ê²€í† **: ê¸°ìˆ  ë¦¬ë·° ë° í”¼ë“œë°± ìˆ˜ë ´
3. **ê°œë°œ í™˜ê²½ ì„¤ì •**: Tauri + SeaORM í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
4. **ë² íƒ€ í…ŒìŠ¤í„° ëª¨ì§‘**: 5ëª… ì‚¬ìš©ì ì„­ì™¸

**ê³„ì† ì§„í–‰í• ê¹Œìš”? ğŸš€**
