# 📊 {변경 내용} 비교 분석 보고서

> **작성일**: {YYYY-MM-DD}
> **작성자**: {이름 또는 팀}
> **브랜치**: `{category}/{description}` vs `main`
> **관련 이슈**: #{issue-number} (선택사항)

---

## 🎯 Executive Summary

### 변경 개요
- **변경 유형**: {architecture / docs / tech / strategy / refactor / experiment}
- **변경 범위**: {파일 개수, 영향받는 서비스 등}
- **목적**: {이 변경을 시도하는 이유}

### 핵심 결과 요약

| 항목 | Before (main) | After (test branch) | 차이 | 평가 |
|------|---------------|---------------------|------|------|
| **파일 크기** | {숫자}줄 | {숫자}줄 | {±숫자}줄 ({±%}%) | 🔽/🔼/➡️ |
| **섹션/모듈 수** | {숫자}개 | {숫자}개 | {±숫자}개 | 🔽/🔼/➡️ |
| **코드 복잡도** | {지표} | {지표} | {±숫자} | 🔽/🔼/➡️ |
| **성능 지표** | {숫자}ms | {숫자}ms | {±숫자}ms | 🔽/🔼/➡️ |
| **테스트 커버리지** | {숫자}% | {숫자}% | {±숫자}% | 🔽/🔼/➡️ |

**추천**: ✅ After 채택 / ❌ Before 유지 / 🤔 추가 검토 필요

---

## 📊 정량적 비교 (Quantitative Analysis)

### 1. 파일 크기 및 구조
```
Before (main):
- 파일 크기: {숫자}줄
- 섹션/모듈 수: {숫자}개
- 코드 블록: {숫자}개
- 주석: {숫자}줄
- 빈 줄: {숫자}줄

After (test branch):
- 파일 크기: {숫자}줄
- 섹션/모듈 수: {숫자}개
- 코드 블록: {숫자}개
- 주석: {숫자}줄
- 빈 줄: {숫자}줄

변화:
- 전체 크기: {±숫자}줄 ({±%}%)
- 실질 코드: {±숫자}줄 ({±%}%)
- 코드/주석 비율: {Before 비율} → {After 비율}
```

### 2. 성능 지표
```
Before (main):
- API 응답 시간 (p50): {숫자}ms
- API 응답 시간 (p95): {숫자}ms
- API 응답 시간 (p99): {숫자}ms
- 메모리 사용량: {숫자}MB
- CPU 사용률: {숫자}%
- 빌드 시간: {숫자}초

After (test branch):
- API 응답 시간 (p50): {숫자}ms
- API 응답 시간 (p95): {숫자}ms
- API 응답 시간 (p99): {숫자}ms
- 메모리 사용량: {숫자}MB
- CPU 사용률: {숫자}%
- 빌드 시간: {숫자}초

변화:
- 응답 시간 (p95): {±숫자}ms ({±%}%)
- 메모리: {±숫자}MB ({±%}%)
- 빌드 시간: {±숫자}초 ({±%}%)
```

### 3. 복잡도 지표
```
Before (main):
- Cyclomatic Complexity: {숫자}
- 함수/메서드 수: {숫자}개
- 평균 함수 길이: {숫자}줄
- 최대 중첩 깊이: {숫자}

After (test branch):
- Cyclomatic Complexity: {숫자}
- 함수/메서드 수: {숫자}개
- 평균 함수 길이: {숫자}줄
- 최대 중첩 깊이: {숫자}

변화:
- 복잡도: {±숫자} ({±%}%)
- 함수 수: {±숫자}개 ({±%}%)
```

### 4. 테스트 커버리지
```
Before (main):
- 유닛 테스트 커버리지: {숫자}%
- 통합 테스트 커버리지: {숫자}%
- E2E 테스트 커버리지: {숫자}%
- 총 테스트 케이스: {숫자}개

After (test branch):
- 유닛 테스트 커버리지: {숫자}%
- 통합 테스트 커버리지: {숫자}%
- E2E 테스트 커버리지: {숫자}%
- 총 테스트 케이스: {숫자}개

변화:
- 유닛 테스트: {±숫자}% ({±%}p)
- 테스트 케이스: {±숫자}개 ({±%}%)
```

### 5. 의존성 분석
```
Before (main):
- 직접 의존성: {숫자}개
- 전체 의존성 (transitive): {숫자}개
- 패키지 크기: {숫자}MB
- 보안 취약점: {숫자}개

After (test branch):
- 직접 의존성: {숫자}개
- 전체 의존성 (transitive): {숫자}개
- 패키지 크기: {숫자}MB
- 보안 취약점: {숫자}개

변화:
- 의존성: {±숫자}개 ({±%}%)
- 패키지 크기: {±숫자}MB ({±%}%)
- 보안 취약점: {±숫자}개
```

### 6. Git 변경 통계
```bash
# 변경된 파일 수
git diff --stat main {branch-name}

# Before 브랜치 기준 변경 라인 수
- 추가: {숫자}줄
- 삭제: {숫자}줄
- 수정: {숫자}파일
```

### 7. 문서화 지표
```
Before (main):
- README 길이: {숫자}줄
- API 문서 페이지: {숫자}개
- 주석 비율: {숫자}%
- 예제 코드: {숫자}개

After (test branch):
- README 길이: {숫자}줄
- API 문서 페이지: {숫자}개
- 주석 비율: {숫자}%
- 예제 코드: {숫자}개

변화:
- 문서 완성도: {평가}
- 예제 코드: {±숫자}개
```

### 8. 빌드/배포 메트릭
```
Before (main):
- Docker 이미지 크기: {숫자}MB
- 빌드 시간: {숫자}초
- 배포 시간: {숫자}초
- CI/CD 성공률: {숫자}%

After (test branch):
- Docker 이미지 크기: {숫자}MB
- 빌드 시간: {숫자}초
- 배포 시간: {숫자}초
- CI/CD 성공률: {숫자}%

변화:
- 이미지 크기: {±숫자}MB ({±%}%)
- 총 배포 시간: {±숫자}초 ({±%}%)
```

### 9. 비용 영향 분석
```
Before (main):
- 월간 서버 비용: ${숫자}
- LLM API 호출 비용: ${숫자}/월
- 스토리지 비용: ${숫자}/월
- 총 운영 비용: ${숫자}/월

After (test branch):
- 월간 서버 비용: ${숫자}
- LLM API 호출 비용: ${숫자}/월
- 스토리지 비용: ${숫자}/월
- 총 운영 비용: ${숫자}/월

변화:
- 총 비용: ${±숫자}/월 ({±%}%)
- 연간 절감/증가: ${±숫자}
```

---

## 🎨 질적 비교 (Qualitative Analysis)

### 1. 가독성 (Readability)

#### Before (main)
**장점**:
- {구체적 장점 1}
- {구체적 장점 2}
- {구체적 장점 3}

**단점**:
- {구체적 단점 1}
- {구체적 단점 2}
- {구체적 단점 3}

**평가**: ⭐⭐⭐⭐☆ (4/5)

#### After (test branch)
**장점**:
- {구체적 장점 1}
- {구체적 장점 2}
- {구체적 장점 3}

**단점**:
- {구체적 단점 1}
- {구체적 단점 2}
- {구체적 단점 3}

**평가**: ⭐⭐⭐⭐⭐ (5/5)

**결론**: ✅ After 승 / ❌ Before 승 / ➡️ 동점

---

### 2. 실용성 (Practicality)

#### Before (main)
**장점**:
- {구체적 장점 1}
- {구체적 장점 2}
- {구체적 장점 3}

**단점**:
- {구체적 단점 1}
- {구체적 단점 2}
- {구체적 단점 3}

**평가**: ⭐⭐⭐☆☆ (3/5)

#### After (test branch)
**장점**:
- {구체적 장점 1}
- {구체적 장점 2}
- {구체적 장점 3}

**단점**:
- {구체적 단점 1}
- {구체적 단점 2}
- {구체적 단점 3}

**평가**: ⭐⭐⭐⭐☆ (4/5)

**결론**: ✅ After 승 / ❌ Before 승 / ➡️ 동점

---

### 3. 유지보수성 (Maintainability)

#### Before (main)
**장점**:
- {구체적 장점 1}
- {구체적 장점 2}
- {구체적 장점 3}

**단점**:
- {구체적 단점 1}
- {구체적 단점 2}
- {구체적 단점 3}

**평가**: ⭐⭐⭐☆☆ (3/5)

#### After (test branch)
**장점**:
- {구체적 장점 1}
- {구체적 장점 2}
- {구체적 장점 3}

**단점**:
- {구체적 단점 1}
- {구체적 단점 2}
- {구체적 단점 3}

**평가**: ⭐⭐⭐⭐⭐ (5/5)

**결론**: ✅ After 승 / ❌ Before 승 / ➡️ 동점

---

### 4. 확장성 (Scalability)

#### Before (main)
**평가**:
- {현재 시스템의 확장 가능성}
- {예상 병목 구간}
- {10x 트래픽 대응 가능 여부}

**평가**: ⭐⭐⭐☆☆ (3/5)

#### After (test branch)
**평가**:
- {개선된 확장 가능성}
- {해결된 병목 구간}
- {10x 트래픽 대응 전략}

**평가**: ⭐⭐⭐⭐☆ (4/5)

**결론**: ✅ After 승 / ❌ Before 승 / ➡️ 동점

---

### 5. 개발자 경험 (Developer Experience)

#### Before (main)
**평가**:
- 학습 곡선: {평가}
- 디버깅 난이도: {평가}
- 개발 속도: {평가}

**평가**: ⭐⭐⭐☆☆ (3/5)

#### After (test branch)
**평가**:
- 학습 곡선: {평가}
- 디버깅 난이도: {평가}
- 개발 속도: {평가}

**평가**: ⭐⭐⭐⭐☆ (4/5)

**결론**: ✅ After 승 / ❌ Before 승 / ➡️ 동점

---

### 6. 보안성 (Security)

#### Before (main)
**평가**:
- 알려진 취약점: {개수}
- 보안 베스트 프랙티스 준수: {평가}
- 암호화 전략: {평가}

**평가**: ⭐⭐⭐⭐☆ (4/5)

#### After (test branch)
**평가**:
- 알려진 취약점: {개수}
- 보안 베스트 프랙티스 준수: {평가}
- 암호화 전략: {평가}

**평가**: ⭐⭐⭐⭐⭐ (5/5)

**결론**: ✅ After 승 / ❌ Before 승 / ➡️ 동점

---

## 📈 트레이드오프 분석 (Trade-offs)

### Before (main)의 장점이자 After의 단점
1. {구체적 항목 1}
2. {구체적 항목 2}
3. {구체적 항목 3}

### After (test branch)의 장점이자 Before의 단점
1. {구체적 항목 1}
2. {구체적 항목 2}
3. {구체적 항목 3}

### 중요도 평가
| 요소 | Before 우위 | After 우위 | 중요도 (1-5) | 가중치 점수 |
|------|-------------|-----------|--------------|-------------|
| {요소 1} | ✅ | ❌ | {숫자} | {Before 점수} |
| {요소 2} | ❌ | ✅ | {숫자} | {After 점수} |
| {요소 3} | ❌ | ✅ | {숫자} | {After 점수} |
| **총점** | - | - | - | **Before: {숫자} / After: {숫자}** |

---

## 🏆 최종 권장사항 (Final Recommendation)

### 추천 결정: ✅ After 채택 / ❌ Before 유지 / 🤔 하이브리드 접근

### 의사결정 근거

**정량적 근거**:
1. {정량적 개선 1}: {숫자} → {숫자} ({±%}%)
2. {정량적 개선 2}: {숫자} → {숫자} ({±%}%)
3. {정량적 개선 3}: {숫자} → {숫자} ({±%}%)

**질적 근거**:
1. {질적 개선 1}: {Before 평가} → {After 평가}
2. {질적 개선 2}: {Before 평가} → {After 평가}
3. {질적 개선 3}: {Before 평가} → {After 평가}

**전략적 근거**:
1. {장기적 비전과의 정렬}
2. {팀 역량 및 리소스 고려}
3. {비즈니스 우선순위}

### 리스크 및 완화 전략

**예상 리스크**:
1. {리스크 1}: {설명}
   - **완화 전략**: {전략}
2. {리스크 2}: {설명}
   - **완화 전략**: {전략}
3. {리스크 3}: {설명}
   - **완화 전략**: {전략}

### 롤백 계획

만약 After 채택 후 문제가 발생하면:
```bash
# 1. 백업 태그 확인
git tag -l "archive/*"

# 2. 롤백 실행
git revert {commit-hash}

# 3. 롤백 보고서 작성
# ROLLBACK_REPORT_{date}.md
```

---

## 📅 실행 계획 (Action Plan)

### 채택시 실행 단계
```bash
# 1. 최종 커밋 (After 버전)
git add .
git commit -m "{커밋 메시지}"

# 2. main 브랜치로 병합
git checkout main
git merge {test-branch-name}

# 3. 백업 브랜치 태그 보존
git tag archive/{test-branch-name} {test-branch-name}

# 4. 테스트 브랜치 삭제
git branch -D {test-branch-name}

# 5. Remote 푸시
git push origin main
git push origin --tags
```

### 유지시 실행 단계
```bash
# 1. 테스트 브랜치 태그 보존 (나중에 참조 가능)
git tag experiment/{test-branch-name} {test-branch-name}

# 2. 테스트 브랜치 삭제
git branch -D {test-branch-name}

# 3. main 브랜치 유지
# (변경사항 없음)

# 4. 실험 결과 문서화
# (이 비교 보고서를 docs/decisions/에 보관)
```

---

## 📚 참고 자료 (References)

### 관련 문서
- [Git 브랜치 백업 전략](docs/development/git-branch-strategy.md)
- [CLAUDE.md](CLAUDE.md)
- [시스템 아키텍처](docs/architecture/system_overview.md)

### 외부 자료
- {관련 기술 문서 URL}
- {벤치마크 자료 URL}
- {베스트 프랙티스 가이드 URL}

### 팀 논의 기록
- {회의록 링크 또는 Slack 쓰레드}
- {의사결정 프로세스 문서}

---

## ✅ 체크리스트 (Checklist)

작성 완료 항목:
- [ ] Executive Summary 작성
- [ ] 정량적 비교 9개 지표 측정
- [ ] 질적 비교 6개 영역 평가
- [ ] 트레이드오프 분석 완료
- [ ] 최종 권장사항 데이터 기반 결정
- [ ] 리스크 및 완화 전략 수립
- [ ] 롤백 계획 수립
- [ ] 실행 계획 명시
- [ ] 팀 리뷰 완료 (협업시)
- [ ] 사용자/이해관계자 승인 (필요시)

---

**이 템플릿을 활용하여 체계적이고 데이터 기반의 의사결정을 내리세요! 🚀**

**작성 팁**:
- 모든 {중괄호} 항목을 실제 데이터로 대체하세요
- 측정 불가능한 지표는 "N/A" 또는 "측정 안 함"으로 표시하세요
- 정량적 데이터를 최우선으로, 질적 평가는 보조 자료로 활용하세요
- 비교 보고서는 향후 참조를 위해 `docs/decisions/` 디렉토리에 보관하세요
